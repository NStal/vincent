// Generated by CoffeeScript 1.10.0
(function() {
  var COMContainer, COMRichText, COMSpell, COMText, Code, CodeBlockHead, CodeBlockTail, CodeDecoration, CodeDecorationMaintainer, CodeDomain, CodeLine, CodeView, Decoration, LanguageManager, customize,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Decoration = COM.COMDecoration;

  COMContainer = COM.COMContainer;

  COMRichText = COM.COMRichText;

  COMSpell = COM.COMSpell;

  COMText = COM.COMText;

  customize = COM.customize;

  CodeBlockHead = require("./spell.codeBlockHead");

  CodeBlockTail = require("./spell.codeBlockTail");

  CodeLine = require("./spell.codeLine");

  CodeView = (function(superClass) {
    extend(CodeView, superClass);

    function CodeView() {
      CodeView.__super__.constructor.call(this, "<div class=\"com com-rich-text\"><div data-id=\"renderer\" class=\"code-render print-not\">Rendering...</div><code data-id=\"container\" class=\"container code\"></code></div>");
      this.rendererId = "code-renderer-" + Math.random().toString().slice(4, 20);
      this.UI.renderer.setAttribute("id", this.rendererId);
    }

    return CodeView;

  })(Leaf.Widget);

  Code = (function(superClass) {
    extend(Code, superClass);

    Code.prototype.type = "Code";

    Code.prototype.mime = "text/plain";

    function Code() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.appearance = {
        tagName: "code",
        classList: ["com", "com-rich-text", "com-code-block"]
      };
      this.childNoTailingBoundary = true;
      if (this.withMarkdownWrapper == null) {
        this.withMarkdownWrapper = true;
      }
      Code.__super__.constructor.apply(this, args);
      if (this.withMarkdownWrapper) {
        this.availableSpells = [CodeBlockHead, CodeBlockTail, CodeLine];
      } else {
        this.availableSpells = [CodeLine];
      }
      this.decorationMaintainers = [];
      this.layout = "block";
      this.composePolicy.behave({
        borrow: true,
        lend: false,
        tailingNewline: true
      });
      this.caretStyle = {
        className: "monokai"
      };
      this.caretStyle = {
        className: "tomorrow"
      };
      this.disableTextHolder = true;
    }

    Code.prototype.specifyDomContainer = function() {
      return this.domContainer = this.cache.view.UI.container;
    };

    Code.prototype.customBaseRender = function() {
      var i, item, len, ref, ref1, results;
      if (!this.cache.view) {
        this.cache.view = new CodeView();
        this.cache.renderer = this.cache.view.UI.renderer;
      }
      this.el = this.cache.view.node;
      this.el.com = this;
      this.el.className = "";
      ref1 = ((ref = this.appearance) != null ? ref.classList : void 0) || [];
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        item = ref1[i];
        results.push(this.el.classList.add(item));
      }
      return results;
    };

    Code.prototype.render = function() {
      var content, cs;
      Code.__super__.render.call(this);
      content = this.getCodeContent();
      this.renderPreview(content, {
        rendererId: this.cache.view.rendererId,
        target: this.cache.view.UI.renderer,
        parent: this.el,
        renderContext: this.rc
      });
      cs = this.contentString;
      if (cs.length < 100 && /^```.*\n\s*```\s*$/.test(cs)) {
        return this.el.classList.add("empty");
      } else {
        return this.el.classList.remove("empty");
      }
    };

    Code.prototype.getCodeContent = function() {
      return this.toHumanString().replace(/^```.*/, "").replace(/```\s*$/, "");
    };

    Code.prototype.compose = function() {
      return Code.__super__.compose.call(this);
    };

    Code.prototype.retainSpells = function() {
      var changed, i, index, item, len, texts;
      if (!this.withMarkdownWrapper) {
        return false;
      }
      texts = this.children.slice();
      for (index = i = 0, len = texts.length; i < len; index = ++i) {
        item = texts[index];
        if (item instanceof CodeBlockHead && index !== 0) {
          item.remove();
          changed = true;
        }
        if (item instanceof CodeBlockTail && index !== texts.length - 1) {
          item.remove();
          changed = true;
        }
      }
      return changed || false;
    };

    Code.prototype.computeDecoration = function() {
      var ref, ref1;
      if (((ref = this.children[0]) != null ? ref.type : void 0) === "CodeBlockHead") {
        this.language = (ref1 = this.children[0]) != null ? typeof ref1.getLanguage === "function" ? ref1.getLanguage() : void 0 : void 0;
        if (this.language !== this.lastLanguage) {
          this.setLanguage(this.language);
        }
        this.lastLanguage = this.language;
      }
      return Code.__super__.computeDecoration.call(this);
    };

    Code.prototype.normalizeTexts = function() {
      if (this.withMarkdownWrapper) {
        return this.normalizeTextsWithMarkdownWrapper();
      } else {
        return this.normalizeTextsSimple();
      }
    };

    Code.prototype.normalizeTextsSimple = function() {
      var atSplit, change, contentString, end, firstLine, i, index, item, j, k, l, lastLine, len, len1, len2, lhs, line, part, parts, ref, texts, toMerge;
      if (this.toHumanString() === "" && this.children.length === 1 && !(this.children[0] instanceof CodeLine)) {
        this.empty();
        this.append(line = new CodeLine(this.context, {
          contentString: ""
        }));
        line.lineNumber = 1;
        line.domProperty = {
          "data-line": index
        };
        return;
      }
      texts = this.children.slice();
      toMerge = "";
      for (index = i = 0, len = texts.length; i < len; index = ++i) {
        item = texts[index];
        if (toMerge) {
          change = true;
          item.insertText(0, toMerge);
          toMerge = "";
        }
        contentString = item.contentString;
        if (contentString.length === 0 && index !== texts.length - 1) {
          change = true;
          item.remove();
          continue;
        }
        parts = contentString.split("\n");
        if (parts.length === 1 && index !== texts.length - 1) {
          change = true;
          toMerge = contentString;
          item.remove();
          continue;
        } else if (parts.length === 1 && index === texts.length - 1) {
          break;
        } else if (parts.length === 2 && parts[1] === "") {
          continue;
        }
        change = true;
        atSplit = contentString;
        if (index !== texts.length - 1) {
          firstLine = parts.shift();
          lastLine = parts.pop();
          item.removeText(0);
          item.insertText(0, firstLine + "\n");
          for (j = parts.length - 1; j >= 0; j += -1) {
            part = parts[j];
            item.after(new CodeLine(this.context, {
              contentString: part + "\n"
            }));
          }
          if (lastLine) {
            toMerge = lastLine;
          }
        } else {
          lastLine = parts.pop();
          if (!lastLine) {
            lastLine = parts.pop();
          }
          end = item.contentString.lastIndexOf(lastLine);
          item.removeText(0, end);
          for (k = 0, len1 = parts.length; k < len1; k++) {
            part = parts[k];
            item.before(new CodeLine(this.context, {
              contentString: part + "\n"
            }));
          }
        }
        continue;
      }
      if (toMerge) {
        change = true;
        this.append(new CodeLine(this.context, {
          contentString: toMerge
        }));
      }
      lhs = this.last().toHumanString();
      if (lhs.slice("-1") === "\n" && lhs !== "\n") {
        change = true;
        this.append(new CodeLine(this.context, {
          contentString: ""
        }));
      }
      if (this.lastLength !== this.children.length) {
        ref = this.children;
        for (index = l = 0, len2 = ref.length; l < len2; index = ++l) {
          item = ref[index];
          item.dirty = true;
          item.lineNumber = index + 1;
          item.domProperty = {
            "data-line": index
          };
        }
      }
      return this.lastLength = this.children.length;
    };

    Code.prototype.normalizeTextsWithMarkdownWrapper = function() {
      var atSplit, change, contentString, end, firstLine, i, index, item, j, k, l, lastLine, len, len1, len2, part, parts, ref, texts, toMerge;
      texts = this.children.slice();
      toMerge = "";
      for (index = i = 0, len = texts.length; i < len; index = ++i) {
        item = texts[index];
        if (toMerge) {
          change = true;
          item.insertText(0, toMerge);
          toMerge = "";
        }
        contentString = item.contentString;
        parts = contentString.split("\n");
        if (parts.length === 1 && index !== texts.length - 1) {
          change = true;
          toMerge = contentString;
          item.remove();
          continue;
        } else if (parts.length === 1 && index === texts.length - 1) {
          break;
        } else if (parts.length === 2 && parts[1] === "") {
          continue;
        }
        change = true;
        atSplit = contentString;
        if (index !== texts.length - 1) {
          firstLine = parts.shift();
          lastLine = parts.pop();
          item.removeText(0);
          item.insertText(0, firstLine + "\n");
          for (j = parts.length - 1; j >= 0; j += -1) {
            part = parts[j];
            item.after(new CodeLine(this.context, {
              contentString: part + "\n"
            }));
          }
          if (lastLine) {
            toMerge = lastLine;
          }
        } else {
          lastLine = parts.pop();
          if (!lastLine) {
            lastLine = parts.pop();
          }
          end = item.contentString.lastIndexOf(lastLine);
          item.removeText(0, end);
          for (k = 0, len1 = parts.length; k < len1; k++) {
            part = parts[k];
            item.before(new CodeLine(this.context, {
              contentString: part + "\n"
            }));
          }
        }
        continue;
      }
      if (toMerge) {
        change = true;
        this.append(new CodeLine(this.context, {
          contentString: toMerge
        }));
      }
      if (this.lastLength !== this.children.length) {
        ref = this.children;
        for (index = l = 0, len2 = ref.length; l < len2; index = ++l) {
          item = ref[index];
          item.dirty = true;
          if (this.withMarkdownWrapper) {
            item.lineNumber = index;
          } else {
            item.lineNumber = index + 1;
          }
          item.domProperty = {
            "data-line": index
          };
        }
      }
      this.lastLength = this.children.length;
      return change || false;
    };

    Code.prototype.castSpells = function() {
      var cl, first, has, i, index, item, last, len, ref;
      ref = this.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (index === 0 && this.withMarkdownWrapper) {
          first = item;
          if (!(first instanceof CodeBlockHead)) {
            has = true;
            new CodeBlockHead(this.context).castToText(first, 0, first.length);
          }
        } else if (index === this.children.length - 1 && this.withMarkdownWrapper) {
          last = item;
          if (!(last instanceof CodeBlockTail)) {
            has = true;
            new CodeBlockTail(this.context).castToText(last, 0, last.length);
          }
        } else if (item.type === "Text") {
          cl = new CodeLine(this.context);
          cl.castToText(item, 0, item.length);
          if (this.withMarkdownWrapper) {
            cl.lineNumber = index;
          } else {
            cl.lineNumber = index + 1;
          }
          has = true;
        }
      }
      return has || false;
    };

    Code.prototype.acknowledge = function() {
      return false;
    };

    Code.prototype.setLanguage = function(language) {
      var plugin, ref, ref1;
      this.decorationMaintainers.length = 0;
      plugin = Code.languages.get(language);
      if (plugin != null ? plugin.decoration : void 0) {
        this.decorationMaintainers.push(plugin.decoration);
      }
      this.appearance.classList.filter(function(item) {
        return item !== "with-preview";
      });
      if (plugin != null ? (ref = plugin.decoration) != null ? (ref1 = ref.domain) != null ? ref1.preview : void 0 : void 0 : void 0) {
        this.appearance.classList.push("with-preview");
        this.renderPreview = plugin.decoration.domain.render;
        return this.dirty = true;
      } else {
        this.appearance.classList = this.appearance.classList.filter(function(item) {
          return item !== "with-preview";
        });
        this.renderPreview = function() {};
        return this.dirty = true;
      }
    };

    Code.prototype.renderPreview = function() {
      return true;
    };

    return Code;

  })(COMRichText);

  LanguageManager = (function() {
    function LanguageManager() {
      this.languages = {};
    }

    LanguageManager.prototype.get = function(language) {
      return this.languages[language] || null;
    };

    LanguageManager.prototype.registerLanguageHighlight = function(name, domain) {
      var base, lang;
      if ((base = this.languages)[name] == null) {
        base[name] = {};
      }
      lang = this.languages[name];
      return lang.decoration = new CodeDecorationMaintainer(name, domain);
    };

    return LanguageManager;

  })();

  Code.languages = new LanguageManager();

  Code.registerLanguageHighlight = function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref = this.languages).registerLanguageHighlight.apply(ref, args);
  };

  CodeDomain = (function() {
    function CodeDomain(info) {
      var i, item, len, modifier, ref, source, sources;
      this.targets = [];
      this.subDomains = [];
      this.preview = info.preview || false;
      this.render = info.render || function() {};
      sources = [];
      ref = info.domains || [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        this.targets.push(item);
        if (item.domain) {
          this.subDomains.push(new CodeDomain(item.domain));
        } else {
          this.subDomains.push(null);
        }
      }
      if (this.targets.length === 0) {
        this.reg = null;
        return;
      }
      source = this.targets.map(function(item) {
        if (item.type === "keyword") {
          return "(\\b" + item.source + "\\b)";
        } else {
          return "(" + item.source + ")";
        }
      }).join("|");
      if (!source) {
        this.reg = null;
      }
      if (info.ignoreCase) {
        modifier = "ig";
      } else {
        modifier = "g";
      }
      this.reg = new RegExp(source, modifier);
    }

    CodeDomain.prototype.analyze = function(string, offset) {
      var content, fix, index, match, result, subDomain, target;
      if (offset == null) {
        offset = 0;
      }
      if (!this.reg) {
        return [];
      }
      result = [];
      this.reg.lastIndex = 0;
      if (string[0] !== " ") {
        string = " " + string;
        fix = -1;
      } else {
        fix = 0;
      }
      while (match = this.reg.exec(string)) {
        if (match[0].length === 0) {
          throw new Error("empty code parsing!");
        }
        index = this.getMatchIndex(match);
        if (index < 0) {
          throw new Error("unexpected parse match", match, this.reg);
        }
        content = match[index];
        target = this.targets[index - 1];
        if (!target) {
          Logger.error(index, content, match, this.reg);
        }
        result.push({
          start: match.index + offset + fix,
          length: match[0].length,
          type: target.type || "custom",
          name: target.name
        });
        if (target.domain && (subDomain = this.subDomains[index - 1])) {
          result.push.apply(result, subDomain.analyze(match[0], match.index + offset + fix));
        }
      }
      return result;
    };

    CodeDomain.prototype.getMatchIndex = function(reg) {
      var i, index, ref;
      for (index = i = 1, ref = reg.length; 1 <= ref ? i < ref : i > ref; index = 1 <= ref ? ++i : --i) {
        if (reg[index]) {
          return index;
        }
      }
      return -1;
    };

    return CodeDomain;

  })();

  CodeDecorationMaintainer = (function(superClass) {
    extend(CodeDecorationMaintainer, superClass);

    function CodeDecorationMaintainer(language1, domain1) {
      this.language = language1;
      this.domain = domain1;
      if (this.domain) {
        this.analyzer = new CodeDomain(this.domain);
      }
    }

    CodeDecorationMaintainer.prototype.compute = function(string) {
      var i, item, len, result;
      result = this.analyzer.analyze(string);
      this.decorations = [];
      for (i = 0, len = result.length; i < len; i++) {
        item = result[i];
        this.decorations.push(new CodeDecoration(this, item.start, item.start + item.length, {
          classes: ["code-highlight-" + item.type, "code-highlight-" + item.type + "-" + (item.name || "anonymous")]
        }));
      }
      return this.decorations;
    };

    return CodeDecorationMaintainer;

  })(Decoration.DecorationMaintainer);

  CodeDecoration = (function(superClass) {
    extend(CodeDecoration, superClass);

    function CodeDecoration(maintainer, start, end1, styles) {
      this.maintainer = maintainer;
      this.start = start;
      this.end = end1;
      this.styles = styles != null ? styles : {};
      this.isCode = true;
    }

    CodeDecoration.prototype.clone = function() {
      return new CodeDecoration(this.maintainer, this.start, this.end, this.styles);
    };

    CodeDecoration.prototype.apply = function(el) {
      var ref;
      return (ref = el.classList).add.apply(ref, this.styles.classes || []);
    };

    CodeDecoration.prototype.cancel = function(el) {
      var ref;
      return (ref = el.classList).remove.apply(ref, this.styles.classes || []);
    };

    CodeDecoration.prototype.equal = function(target) {
      return target.isCode && target.start === this.start && target.end === this.end && this.maintainer.language === target.maintainer.language;
    };

    return CodeDecoration;

  })(Decoration);

  module.exports = Code;

}).call(this);

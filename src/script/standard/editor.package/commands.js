// Generated by CoffeeScript 1.10.0
(function() {
  var addCommand, commands,
    slice = [].slice;

  commands = [];

  addCommand = function(command) {
    return commands.push(command);
  };

  addCommand({
    name: "cancel-selection",
    description: "cancel the current selection",
    handler: function(editor) {
      var ref, ref1;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return (ref1 = editor.buffer) != null ? ref1.selection.cancel() : void 0;
    }
  });

  addCommand({
    name: "active-selection",
    description: "active the selection so you can expand it",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return false;
    }
  });

  addCommand({
    name: "toggle-selection-active",
    description: "toggle the activation of the selection so you can expand it",
    handler: function(editor) {
      var ref, ref1, ref2;
      if ((ref = editor.buffer) != null ? ref.selection.isActive : void 0) {
        if ((ref1 = editor.buffer) != null) {
          ref1.selection.deactivate();
        }
      } else {
        if ((ref2 = editor.buffer) != null) {
          ref2.selection.activate();
        }
      }
      return false;
    }
  });

  addCommand({
    name: "deactive-selection",
    description: "deactive the selection so you can easily cancel it",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.deactivate();
      }
      return false;
    }
  });

  addCommand({
    name: "forward-char",
    description: "forward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.caret.forwardChar();
    }
  });

  addCommand({
    name: "backward-char",
    description: "backward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.caret.backwardChar();
    }
  });

  addCommand({
    name: "backward-word",
    description: "backward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("backwardWord");
    }
  });

  addCommand({
    name: "forward-word",
    description: "forward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("forwardWord");
    }
  });

  addCommand({
    name: "upward-char",
    description: "move the cursor upward",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.caret.upwardChar();
    }
  });

  addCommand({
    name: "downward-char",
    description: "move the cursor downward",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.caret.downwardChar();
    }
  });

  addCommand({
    name: "write",
    description: "write a string <value> at the current cursor",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.caret.write(value);
    }
  });

  addCommand({
    name: "delete-char",
    description: "delete char at the current cursor",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("deleteChar");
    }
  });

  addCommand({
    name: "delete-line-before-cursor",
    description: "delete line at the current charactor",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("deleteLineBeforeCursor");
    }
  });

  addCommand({
    name: "delete-word",
    description: "delete word at the current cursor",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("deleteWord");
    }
  });

  addCommand({
    name: "delete-current-word",
    description: "delete next word after the current cursor",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      if (!editor.buffer.cursor.conduct("forwardWord")) {
        return false;
      }
      return editor.buffer.cursor.conduct("deleteWord");
    }
  });

  addCommand({
    name: "previous-page",
    description: "scroll the view port to previous page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      editor.buffer.viewPort.previousPage();
      editor.caret.moveToViewPortCenter();
      return true;
    }
  });

  addCommand({
    name: "go-top",
    description: "scroll the view port to previous page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      editor.caret.begin();
      return true;
    }
  });

  addCommand({
    name: "go-bottom",
    description: "scroll the view port to previous page and set cursor if needed",
    handler: function(editor) {
      var ref, ref1;
      if ((ref = editor.buffer) != null) {
        if ((ref1 = ref.selection) != null) {
          ref1.cancel();
        }
      }
      editor.caret.end();
      return true;
    }
  });

  addCommand({
    name: "next-page",
    description: "scroll the view port to next page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      editor.buffer.viewPort.nextPage();
      editor.caret.moveToViewPortCenter();
      return true;
    }
  });

  addCommand({
    name: "selective-forward-char",
    description: "forward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.caret.forwardChar();
    }
  });

  addCommand({
    name: "selective-backward-char",
    description: "backward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.caret.backwardChar();
    }
  });

  addCommand({
    name: "selective-backward-word",
    description: "backward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.buffer.cursor.conduct("backwardWord");
    }
  });

  addCommand({
    name: "selective-forward-word",
    description: "forward the cursor to next char",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.buffer.cursor.conduct("forwardWord");
    }
  });

  addCommand({
    name: "selective-upward-char",
    description: "move the cursor upward",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.caret.upwardChar();
    }
  });

  addCommand({
    name: "selective-downward-char",
    description: "move the cursor downward",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.caret.downwardChar();
    }
  });

  addCommand({
    name: "selective-write",
    description: "write a string <value> at the current cursor",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.caret.write(value);
    }
  });

  addCommand({
    name: "selective-delete-char",
    description: "write a string <value> at the current cursor",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.buffer.cursor.conduct("deleteChar");
    }
  });

  addCommand({
    name: "selective-delete-word",
    description: "write a string <value> at the current cursor",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.buffer.cursor.conduct("deleteWord");
    }
  });

  addCommand({
    name: "selective-previous-page",
    description: "scroll the view port to previous page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      editor.buffer.viewPort.previousPage();
      editor.caret.moveToViewPortCenter();
      return true;
    }
  });

  addCommand({
    name: "selective-go-top",
    description: "scroll the view port to previous page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      editor.caret.begin();
      return true;
    }
  });

  addCommand({
    name: "selective-go-bottom",
    description: "scroll the view port to previous page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      editor.caret.end();
      return true;
    }
  });

  addCommand({
    name: "selective-next-page",
    description: "scroll the view port to next page and set cursor if needed",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      editor.buffer.viewPort.nextPage();
      editor.caret.moveToViewPortCenter();
      return true;
    }
  });

  addCommand({
    name: "force-trigger",
    description: "active a component if it can be",
    handler: function() {
      var args, editor, value;
      editor = arguments[0], value = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (value == null) {
        value = {};
      }
      value.force = true;
      return editor.buffer.cursor.conduct("trigger", value);
    }
  });

  addCommand({
    name: "trigger",
    description: "active a component if it can be",
    handler: function() {
      var args, editor, value;
      editor = arguments[0], value = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      return editor.buffer.cursor.conduct("trigger", value);
    }
  });

  addCommand({
    name: "undo",
    description: "undo the change",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      editor.context.history.backward();
      return true;
    }
  });

  addCommand({
    name: "redo",
    description: "redo the change",
    handler: function(editor, value) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      editor.context.history.forward();
      return true;
    }
  });

  addCommand({
    name: "push-history",
    description: "push history to history stack (will clear the redo buffer)",
    handler: function(editor) {
      editor.context.history.debug();
      return true;
    }
  });

  addCommand({
    name: "select-all",
    description: "select everything",
    handler: function(editor) {
      var ref;
      return (ref = editor.buffer) != null ? ref.selection.selectAll() : void 0;
    }
  });

  addCommand({
    name: "void",
    description: "do nothing but return true",
    handler: function() {
      return true;
    }
  });

  addCommand({
    name: "trigger-rune",
    description: "trigger current target if it's a rune",
    handler: function(editor) {
      var target;
      target = editor.buffer.cursor.target;
      if (target.sortOf("Rune")) {
        return editor.buffer.cursor.conduct("trigger");
      }
      return false;
    }
  });

  addCommand({
    name: "delete-selection",
    description: "delete selected contents",
    handler: function(editor) {
      var ref, ref1, ref2;
      if (((ref = editor.buffer) != null ? ref.selection.isCollapsed() : void 0) || !((ref1 = editor.buffer) != null ? ref1.selection.isActive : void 0)) {
        return false;
      }
      if ((ref2 = editor.buffer) != null) {
        ref2.selection.removeSelectedNodes();
      }
      return true;
    }
  });

  addCommand({
    name: "next-rune",
    description: "move cursor to next rune if possible",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("nextRune");
    }
  });

  addCommand({
    name: "previous-rune",
    description: "move cursor to previous rune if possible",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("previousRune");
    }
  });

  addCommand({
    name: "start-of-line",
    description: "move cursor to start of the line",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("startOfLine");
    }
  });

  addCommand({
    name: "end-of-line",
    description: "move cursor to end of the line",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      return editor.buffer.cursor.conduct("endOfLine");
    }
  });

  addCommand({
    name: "start-of-spell",
    description: "move cursor to start of the current spell",
    handler: function(editor) {
      var cursor, prev, ref, ref1, ref2, text;
      cursor = editor.buffer.cursor;
      cursor.target.reflow();
      text = (ref = cursor.target) != null ? ref.getChildTextByOffset(cursor.anchor.index) : void 0;
      if (text.isSpell && cursor.anchor.index > text.startOffset) {
        if ((ref1 = editor.buffer) != null) {
          ref1.selection.cancel();
        }
        cursor.anchor.index = text.startOffset;
        return true;
      } else if (cursor.anchor.index === text.startOffset && cursor.anchor.index > 1) {
        prev = cursor.target.getChildTextByOffset(cursor.anchor.index - 1);
        if (prev && prev.isSpell) {
          if ((ref2 = editor.buffer) != null) {
            ref2.selection.cancel();
          }
          cursor.anchor.index = prev.startOffset;
          return true;
        }
      }
      return false;
    }
  });

  addCommand({
    name: "end-of-spell",
    description: "move cursor to start of the current spell",
    handler: function(editor) {
      var cursor, ref, ref1, text;
      cursor = editor.buffer.cursor;
      cursor.target.reflow();
      text = (ref = cursor.target) != null ? ref.getChildTextByOffset(cursor.anchor.index) : void 0;
      if (text != null ? text.noEyeCatching : void 0) {
        return;
      }
      if (text.isSpell && cursor.anchor.index < text.endOffset) {
        if ((ref1 = editor.buffer) != null) {
          ref1.selection.cancel();
        }
        cursor.anchor.index = text.endOffset;
        if (text.contentString[text.contentString.length - 1] === "\n") {
          cursor.anchor.index -= 1;
        }
        return true;
      }
      return false;
    }
  });

  addCommand({
    name: "selective-start-of-spell",
    description: "move cursor to start of the current spell",
    handler: function(editor) {
      var cursor, prev, ref, ref1, ref2, text;
      cursor = editor.buffer.cursor;
      cursor.target.reflow();
      text = (ref = cursor.target) != null ? ref.getChildTextByOffset(cursor.anchor.index) : void 0;
      if (text.isSpell && cursor.anchor.index > text.startOffset) {
        if ((ref1 = editor.buffer) != null) {
          ref1.selection.activate();
        }
        cursor.anchor.index = text.startOffset;
        return true;
      } else if (cursor.anchor.index === text.startOffset && cursor.anchor.index > 1) {
        prev = cursor.target.getChildTextByOffset(cursor.anchor.index - 1);
        if (prev && prev.isSpell) {
          if ((ref2 = editor.buffer) != null) {
            ref2.selection.activate();
          }
          cursor.anchor.index = prev.startOffset;
          return true;
        }
      }
      return false;
    }
  });

  addCommand({
    name: "selective-end-of-spell",
    description: "move cursor to start of the current spell",
    handler: function(editor) {
      var cursor, ref, ref1, text;
      cursor = editor.buffer.cursor;
      cursor.target.reflow();
      text = (ref = cursor.target) != null ? ref.getChildTextByOffset(cursor.anchor.index) : void 0;
      if (text != null ? text.noEyeCatching : void 0) {
        return;
      }
      if ((text != null ? text.isSpell : void 0) && cursor.anchor.index < text.endOffset) {
        if ((ref1 = editor.buffer) != null) {
          ref1.selection.activate();
        }
        cursor.anchor.index = text.endOffset;
        if (text.contentString[text.contentString.length - 1] === "\n") {
          cursor.anchor.index -= 1;
        }
        return true;
      }
      return false;
    }
  });

  addCommand({
    name: "selective-start-of-line",
    description: "move cursor to start of the line",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.buffer.cursor.conduct("startOfLine");
    }
  });

  addCommand({
    name: "selective-end-of-line",
    description: "move cursor to end of the line",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.activate();
      }
      return editor.buffer.cursor.conduct("endOfLine");
    }
  });

  addCommand({
    name: "delete-current-char",
    description: "delete the current char not the previous",
    handler: function(editor) {
      var ref;
      if ((ref = editor.buffer) != null) {
        ref.selection.cancel();
      }
      if (!editor.buffer.cursor.conduct("forwardChar")) {
        return false;
      }
      return editor.buffer.cursor.conduct("deleteChar");
    }
  });

  addCommand({
    name: "wrap-selection",
    description: "wrap the selection with certain char and move caret to end",
    handler: function(editor, left, right) {
      var col, cursor, index, leftIndex, ref, rightIndex, selection;
      if (left == null) {
        left = "";
      }
      if (right == null) {
        right = "";
      }
      if (!left && !right) {
        return false;
      }
      selection = (ref = editor.buffer) != null ? ref.selection : void 0;
      if (!selection.isActive || selection.isCollapsed()) {
        return false;
      }
      col = selection.getSelectedCollection();
      if (col.beginNode !== col.endNode) {
        return false;
      }
      if (!col.beginNode.sortOf("RichText")) {
        return false;
      }
      leftIndex = col.beginAnchor.index;
      rightIndex = col.endAnchor.index + left.length;
      col.beginNode.insertText(leftIndex, left);
      col.beginNode.insertText(rightIndex, right);
      index = col.endAnchor.index;
      cursor = editor.buffer.cursor;
      cursor.pointAtAnchor(col.endAnchor);
      cursor.anchor.index += left.length + right.length;
      selection.collapseToCursor();
      return true;
    }
  });

  addCommand({
    name: "selection-collapse-to-begin",
    descrioption: "collapse the selection to begin of it",
    handler: function(editor) {
      var ref, ref1, selection;
      selection = (ref = editor.buffer) != null ? ref.selection : void 0;
      if (!selection.isActive || ((ref1 = editor.buffer) != null ? ref1.selection.isCollapsed() : void 0)) {
        return false;
      }
      return selection.collapseToBegin();
    }
  });

  addCommand({
    name: "selection-collapse-to-end",
    descrioption: "collapse the selection to end of it",
    handler: function(editor) {
      var ref, ref1, selection;
      selection = (ref = editor.buffer) != null ? ref.selection : void 0;
      if (!selection.isActive || ((ref1 = editor.buffer) != null ? ref1.selection.isCollapsed() : void 0)) {
        return false;
      }
      return selection.collapseToEnd();
    }
  });

  addCommand({
    name: "next-focus-frame",
    description: "focus to next focusable editor frame",
    handler: function(editor) {
      return editor.layout.nextFocus();
    }
  });

  addCommand({
    name: "previous-focus-frame",
    description: "focus to previous focusable editor frame",
    handler: function(editor) {
      return editor.layout.previousFocus();
    }
  });

  addCommand({
    name: "indent-normal-line",
    description: "indent the current line forward if possible",
    handler: function(editor) {
      var base, cursor, indent;
      cursor = editor.buffer.cursor;
      cursor.state.save();
      if (!cursor.anchor.startOfLine({
        begin: true
      }) && cursor.anchor.index > 0) {
        cursor.state.restore();
        return false;
      }
      indent = "    ";
      if (typeof (base = cursor.target).insertText === "function") {
        base.insertText(cursor.anchor.index, indent);
      }
      cursor.state.restore();
      return true;
    }
  });

  addCommand({
    name: "backindent-normal-line",
    description: "indent the current line backward if possible",
    handler: function(editor) {
      var base, cs, cursor, indent;
      cursor = editor.buffer.cursor;
      cursor.state.save();
      if (!cursor.anchor.startOfLine({
        begin: true
      }) && cursor.anchor.index > 0) {
        cursor.state.restore();
        return false;
      }
      cs = cursor.target.contentString;
      if (!cs) {
        cursor.state.restore();
        return false;
      }
      indent = "    ";
      if (cs.slice(cursor.anchor.index, cursor.anchor.index + 4) !== indent) {
        cursor.state.restore();
        return false;
      }
      if (typeof (base = cursor.target).removeText === "function") {
        base.removeText(cursor.anchor.index, 4);
      }
      cursor.state.restore();
      return true;
    }
  });

  addCommand({
    name: "write-newline",
    description: "insert a new line at the current position",
    handler: function(editor) {
      return editor.conduct("write", "\n");
    }
  });

  module.exports = commands;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer, COMRichText, LeftInvokeOneLineElementExtractor, LeftInvokeOneLineElementRetainer, PairedElementExtractor, PairedElementRetainer, RichTextBasedComposer,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  COMComposer = COM.COMComposer;

  COMRichText = COM.COMRichText;

  RichTextBasedComposer = (function(superClass) {
    extend(RichTextBasedComposer, superClass);

    function RichTextBasedComposer() {
      return RichTextBasedComposer.__super__.constructor.apply(this, arguments);
    }

    RichTextBasedComposer.prototype.distributeAnchor = function(children, option) {
      var anchor, atom, child, i, index, j, k, len, len1, len2, length, next, offset, ref, ref1, ref2, target;
      if (option == null) {
        option = {};
      }
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (!(child instanceof COMRichText)) {
          return false;
        }
      }
      ref = this.target.anchors;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        anchor = ref[j];
        offset = anchor.index;
        for (index = k = 0, len2 = children.length; k < len2; index = ++k) {
          atom = children[index];
          length = atom.length;
          next = children[index + 1];
          if (false && index !== 0 && atom instanceof BlockAtomElement) {
            offset -= 1;
          }
          if (offset > length) {
            offset -= length;
            continue;
          } else if (offset === length && index === children.length - 1) {
            target = atom;
            break;
          } else if (false && offset === length && next instanceof BlockAtomElement) {
            target = atom;
            break;
          } else if (offset === length) {
            offset = 0;
            continue;
          } else {
            target = atom;
            break;
          }
        }
        if (target) {
          if ((ref1 = anchor.cursor) != null) {
            ref1.context.pointIdenticalCursors(anchor.cursor, target, {
              index: offset
            });
          }
          continue;
        }
        if (option.fallback) {
          if ((ref2 = anchor.cursor) != null) {
            ref2.context.pointIdenticalCursors(anchor.cursor, children[0], {
              index: 0
            });
          }
          continue;
        }
      }
      return true;
    };

    return RichTextBasedComposer;

  })(COMComposer);

  LeftInvokeOneLineElementExtractor = (function(superClass) {
    extend(LeftInvokeOneLineElementExtractor, superClass);

    function LeftInvokeOneLineElementExtractor() {
      return LeftInvokeOneLineElementExtractor.__super__.constructor.apply(this, arguments);
    }

    LeftInvokeOneLineElementExtractor.prototype.type = "Void";

    LeftInvokeOneLineElementExtractor.prototype.reg = null;

    LeftInvokeOneLineElementExtractor.prototype.backwardAssert = "\n";

    LeftInvokeOneLineElementExtractor.prototype.exec = function() {
      var backwardAssert, backwardAssertString, backwardFix, children, content, contentAfter, contentBefore, contentString, end, forwardAssert, forwardAssertString, forwardFix, index, lastChar, match, parent, reg, renderTarget, start;
      contentString = this.target.contentString;
      reg = this.reg;
      match = contentString.match(reg);
      if (match) {
        backwardFix = 0;
        forwardFix = 0;
        backwardAssert = this.backwardAssert || "";
        forwardAssert = this.forwardAssert || "";
        backwardAssertString = match[0].slice(0, backwardAssert.length);
        if (backwardAssertString === backwardAssert) {
          backwardFix = backwardAssert.length;
        }
        forwardAssertString = match[0].slice(-forwardAssert.length);
        if (forwardAssertString === forwardAssert) {
          forwardFix = forwardAssert.length;
        }
        lastChar = match[0].slice(-1);
        if (lastChar !== "\n" && this.target.next()) {
          return false;
        }
        content = match[0].slice(backwardFix, -forwardFix || match[0].length);
        start = match.index + backwardFix;
        end = start + content.length;
        contentBefore = contentString.slice(0, start);
        contentAfter = contentString.slice(end);
        renderTarget = this.context.createElement(this.renderTargetType, {
          contentString: content
        });
        this.rt = renderTarget;
        children = [];
        if (contentBefore) {
          children.push(this.context.createElement("RichText", {
            contentString: contentBefore
          }));
        }
        children.push(renderTarget);
        if (contentAfter) {
          children.push(this.context.createElement("RichText", {
            contentString: contentAfter
          }));
        }
        parent = this.target.parent;
        index = parent.indexOf(this.target);
        parent.removeChild(index);
        parent.insert.apply(parent, [index].concat(slice.call(children)));
        this.distributeAnchor(children);
        return true;
      } else {
        return false;
      }
    };

    LeftInvokeOneLineElementExtractor.prototype.exec = function() {
      var backwardAssert, backwardAssertString, backwardFix, children, content, contentAfter, contentBefore, contentString, end, forwardAssert, forwardAssertString, forwardFix, index, lastChar, match, parent, reg, renderTarget, start;
      contentString = this.target.contentString;
      reg = this.reg;
      match = contentString.match(reg);
      if (match) {
        backwardFix = 0;
        forwardFix = 0;
        backwardAssert = this.backwardAssert || "";
        forwardAssert = this.forwardAssert || "";
        backwardAssertString = match[0].slice(0, backwardAssert.length);
        if (backwardAssertString === backwardAssert) {
          backwardFix = backwardAssert.length;
        }
        forwardAssertString = match[0].slice(-forwardAssert.length);
        if (forwardAssertString === forwardAssert) {
          forwardFix = forwardAssert.length;
        }
        lastChar = match[0].slice(-1);
        if (lastChar !== "\n" && this.target.next()) {
          return false;
        }
        content = match[0].slice(backwardFix, -forwardFix || match[0].length);
        start = match.index + backwardFix;
        end = start + content.length;
        contentBefore = contentString.slice(0, start);
        contentAfter = contentString.slice(end);
        renderTarget = this.context.createElement(this.renderTargetType, {
          contentString: content
        });
        this.rt = renderTarget;
        children = [];
        if (contentBefore) {
          children.push(this.context.createElement("RichText", {
            contentString: contentBefore
          }));
        }
        children.push(renderTarget);
        if (contentAfter) {
          children.push(this.context.createElement("RichText", {
            contentString: contentAfter
          }));
        }
        parent = this.target.parent;
        index = parent.indexOf(this.target);
        parent.removeChild(index);
        parent.insert.apply(parent, [index].concat(slice.call(children)));
        this.distributeAnchor(children);
        return true;
      } else {
        return false;
      }
    };

    return LeftInvokeOneLineElementExtractor;

  })(RichTextBasedComposer);

  LeftInvokeOneLineElementRetainer = (function(superClass) {
    extend(LeftInvokeOneLineElementRetainer, superClass);

    function LeftInvokeOneLineElementRetainer() {
      return LeftInvokeOneLineElementRetainer.__super__.constructor.apply(this, arguments);
    }

    LeftInvokeOneLineElementRetainer.prototype.reg = null;

    LeftInvokeOneLineElementRetainer.prototype.exec = function() {
      var after, afterContent, afters, before, beforeContent, befores, contentString, emptylineReg, index, last, leftContent, line, lines, match, next, reg, replacement;
      contentString = this.target.contentString;
      reg = this.reg;
      match = contentString.match(reg);
      if (match && match.index + match[0].length === contentString.length) {
        last = contentString[contentString.length - 1];
        next = this.target.next();
        index = this.target.parent.indexOf(this.target);
        if (!next || last === "\n") {
          return false;
        }
        if (this.target.composePolicy.borrow && next && (line = next.borrowFirstLine())) {
          this.target.contentString = contentString + line;
          return true;
        }
      }
      lines = this.target.contentString.split("\n");
      afters = [];
      befores = [];
      emptylineReg = /^\s*$/;
      while (true) {
        line = lines.pop();
        if (typeof line === "string" && emptylineReg.test(line)) {
          afters.unshift(line);
        } else if (typeof line === "string") {
          lines.push(line);
          break;
        } else {
          break;
        }
      }
      while (true) {
        line = lines.shift();
        if (typeof line === "string" && emptylineReg.test(line)) {
          befores.push(line);
        } else if (typeof line === "string") {
          lines.unshift(line);
          break;
        } else {
          break;
        }
      }
      if (befores.length > 0) {
        beforeContent = befores.join("\n") + "\n";
        before = this.context.createElement("RichText", {
          contentString: beforeContent
        });
        this.target.before(before);
      }
      if (afters.length > 1) {
        afterContent = afters.join("\n");
        after = this.context.createElement("RichText", {
          contentString: afterContent
        });
        this.target.after(after);
      }
      if (beforeContent || afterContent) {
        if (beforeContent == null) {
          beforeContent = "";
        }
        if (afterContent == null) {
          afterContent = "";
        }
        this.target.removeText(0, beforeContent.length);
        leftContent = this.target.contentString;
        this.target.removeText(leftContent.length - afterContent.length, afterContent.length);
        return true;
      }
      replacement = this.context.createElement("RichText", {
        contentString: contentString
      });
      this.target.replaceBy(replacement);
      this.distributeAnchor([replacement]);
      if (typeof this.atRelease === "function") {
        this.atRelease(this.target, replacement);
      }
      return true;
    };

    return LeftInvokeOneLineElementRetainer;

  })(RichTextBasedComposer);

  PairedElementExtractor = (function(superClass) {
    extend(PairedElementExtractor, superClass);

    function PairedElementExtractor() {
      return PairedElementExtractor.__super__.constructor.apply(this, arguments);
    }

    PairedElementExtractor.prototype.backwardAssert = "\n";

    PairedElementExtractor.prototype.exec = function() {
      var backwardAssert, backwardAssertString, backwardFix, children, content, contentAfter, contentBefore, contentString, end, forwardAssert, forwardAssertString, forwardFix, index, lastChar, match, parent, previous, ref, reg, renderTarget, start;
      contentString = this.target.contentString;
      reg = this.reg;
      match = contentString.match(reg);
      if (match) {
        backwardFix = 0;
        forwardFix = 0;
        backwardAssert = this.backwardAssert || "";
        forwardAssert = this.forwardAssert || "";
        backwardAssertString = match[0].slice(0, backwardAssert.length);
        if (backwardAssertString === backwardAssert) {
          backwardFix = backwardAssert.length;
        }
        forwardAssertString = match[0].slice(-forwardAssert.length);
        if (forwardAssertString === forwardAssert) {
          forwardFix = forwardAssert.length;
        }
        lastChar = match[0].slice(-1);
        if (lastChar !== "\n" && this.target.next()) {
          return false;
        }
        if (match[0][0] !== "\n" && (previous = this.target.previous())) {
          if (previous.sortOf("RichText") && ((ref = previous.contentString) != null ? ref.slice(-1) : void 0) === "\n") {
            true;
          } else {
            return false;
          }
        }
        content = match[0].slice(backwardFix, -forwardFix || match[0].length);
        start = match.index + backwardFix;
        end = start + content.length;
        contentBefore = contentString.slice(0, start);
        contentAfter = contentString.slice(end);
        renderTarget = this.context.createElement(this.renderTargetType, {
          contentString: content
        });
        children = [];
        if (contentBefore) {
          children.push(this.context.createElement("RichText", {
            contentString: contentBefore
          }));
        }
        children.push(renderTarget);
        if (contentAfter) {
          children.push(this.context.createElement("RichText", {
            contentString: contentAfter
          }));
        }
        parent = this.target.parent;
        index = parent.indexOf(this.target);
        parent.removeChild(index);
        parent.insert.apply(parent, [index].concat(slice.call(children)));
        this.distributeAnchor(children);
        return true;
      } else {
        return false;
      }
    };

    return PairedElementExtractor;

  })(RichTextBasedComposer);

  PairedElementRetainer = (function(superClass) {
    extend(PairedElementRetainer, superClass);

    function PairedElementRetainer() {
      return PairedElementRetainer.__super__.constructor.apply(this, arguments);
    }

    PairedElementRetainer.prototype.fastRetain = function(cs) {
      return false;
    };

    PairedElementRetainer.prototype.exec = function() {
      var contentString, index, last, line, match, next, reg, replacement;
      contentString = this.target.contentString;
      if (this.fastRetain(contentString)) {
        return false;
      }
      reg = this.reg;
      match = contentString.match(reg);
      if (match && match.index + match[0].length === contentString.length) {
        last = contentString[contentString.length - 1];
        next = this.target.next();
        index = this.target.parent.indexOf(this.target);
        if (!next || last === "\n") {
          return false;
        }
        if (this.target.composePolicy.borrow && next && (line = next.borrowFirstLine())) {
          this.target.contentString = contentString + line;
          return true;
        }
        return false;
      }
      replacement = this.context.createElement("RichText", {
        contentString: contentString
      });
      this.target.replaceBy(replacement);
      this.distributeAnchor([replacement]);
      return true;
    };

    return PairedElementRetainer;

  })(RichTextBasedComposer);

  module.exports = {
    RichTextBasedComposer: RichTextBasedComposer,
    LeftInvokeOneLineElementRetainer: LeftInvokeOneLineElementRetainer,
    LeftInvokeOneLineElementExtractor: LeftInvokeOneLineElementExtractor,
    PairedElementRetainer: PairedElementRetainer,
    PairedElementExtractor: PairedElementExtractor,
    COMComposer: COMComposer
  };

}).call(this);

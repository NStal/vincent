// Generated by CoffeeScript 1.10.0
(function() {
  var BoundaryEffectTracer, Caret, CaretActionTrait, CaretBlinkableTrait, CaretLayout, CaretPosition, CaretViewPortPoserTrait, CaretWritableTrait, DOMBoundary, DOMRegion, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DOMRegion = require("../common/region");

  DOMBoundary = require("../common/boundary");

  EventEmitter = (require("../common/events")).EventEmitter;

  Caret = (function(superClass) {
    extend(Caret, superClass);

    function Caret(editor, option) {
      this.editor = editor;
      if (option == null) {
        option = {};
      }
      this.template = "<div class=\"caret\" data-class=\"caretName,visibleState\"><div data-id=\"shape\" class=\"shape\"></div></div>";
      Caret.__super__.constructor.call(this);
      this.name = option.name || "master";
      this.VM.caretName = "caret-" + this.name;
      this.shape = this.UI.shape;
      this.shape$ = this.UI.shape$;
      this.__defineGetter__("dirty", (function(_this) {
        return function() {
          return _this._dirty;
        };
      })(this));
      this.__defineSetter__("dirty", (function(_this) {
        return function(value) {
          return _this._dirty = value;
        };
      })(this));
      this.boundaryEffectTracer = new BoundaryEffectTracer(this);
    }

    Caret.prototype.init = function() {
      window.addEventListener("resize", (function(_this) {
        return function() {
          return _this.dirty = true;
        };
      })(this));
      this.node.addEventListener("mousedown", (function(_this) {
        return function(e) {
          return _this.onClick(e);
        };
      })(this));
      if (this.editor.platform.isMobile()) {
        this.editor.inputMethod.listenBy(this, "key", (function(_this) {
          return function(e) {
            if (e.simulateName) {
              return setTimeout(function() {
                _this.isScrolling = false;
                return _this.dirty = true;
              }, 0);
            }
          };
        })(this));
      }
      this.keyHandlers = {};
      new CaretViewPortPoserTrait(this);
      new CaretActionTrait(this);
      return new CaretBlinkableTrait(this);
    };

    Caret.prototype.destroy = function() {
      var ref, ref1, ref2, ref3;
      this.editor.inputMethod.stopListenBy(this);
      if ((ref = this.cursor) != null) {
        ref.stopListenBy(this);
      }
      if ((ref1 = this.context) != null) {
        ref1.stopListenBy(this);
      }
      if ((ref2 = this.currentBuffer) != null) {
        ref2.stopListenBy(this);
      }
      return (ref3 = this.node.parentElement) != null ? ref3.removeChild(this.node) : void 0;
    };

    Caret.prototype.dirtyConfirm = function() {
      clearTimeout(this.dirtyConfirmTimer);
      return this.dirtyConfirmTimer = setTimeout((function(_this) {
        return function() {
          return _this.dirty = true;
        };
      })(this), 10);
    };

    Caret.prototype.attachTo = function(buffer, cursor) {
      if (!buffer.interactive) {
        return false;
      }
      if (this.cursor) {
        this.cursor.stopListenBy(this);
      }
      if (this.context) {
        this.context.stopListenBy(this);
      }
      if (this.currentBuffer) {
        this.currentBuffer.stopListenBy(this);
      }
      this.dirty = true;
      this.viewPort = buffer.viewPort;
      this.currentBuffer = buffer;
      buffer.ensureRenderContext();
      this.cursor = cursor || buffer.cursor;
      this.cursor.listenBy(this, "move", (function(_this) {
        return function() {
          _this.currentBuffer.disableSaveBestPosition = false;
          _this.isScrolling = false;
          if (_this.name === "master") {
            _this.requestScroll = true;
          }
          return _this.dirty = true;
        };
      })(this));
      this.cursor.listenBy(this, "trigger", (function(_this) {
        return function() {
          return _this.forceBump = true;
        };
      })(this));
      this.context = buffer.context;
      this.context.listenBy(this, "change", (function(_this) {
        return function() {
          _this.dirty = true;
          if (_this.name === "master") {
            _this.requestScroll = true;
          }
          if (_this.node.parentElement !== _this.currentBuffer.viewPort.el) {
            _this.currentBuffer.viewPort.el.appendChild(_this.node);
          }
          return _this.dirtyConfirm();
        };
      })(this));
      this.currentBuffer.listenBy(this, "interactiveChange", function(change) {
        return this.update();
      });
      this.currentBuffer.listenBy(this, "resize", (function(_this) {
        return function() {
          return _this.dirty = true;
        };
      })(this));
      this.currentBuffer.listenBy(this, "reflow", (function(_this) {
        return function() {
          _this.emit("bufferReflow");
          if (!_this.editor.platform.isMobile()) {
            return;
          }
          _this.isScrolling = true;
          clearTimeout(_this._scrollTimer);
          return _this._scrollTimer = setTimeout(function() {
            return _this.isScrolling = false;
          }, 350);
        };
      })(this));
      this.switchingBuffer = true;
      if (this.isShow) {
        this.isShow = false;
        this.show();
        return this.update();
      }
    };

    Caret.prototype.onClick = function(e) {
      if (e.which !== 1) {
        return;
      }
      if (this.editor.conduct("trigger")) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return;
      }
      return false;
    };

    Caret.prototype.compareRect = function(a, b) {
      var i, len, prop, props;
      props = ["left", "right", "top", "bottom"];
      for (i = 0, len = props.length; i < len; i++) {
        prop = props[i];
        if (parseInt(a[prop]) !== parseInt(b[prop])) {
          return false;
        }
      }
      return true;
    };

    Caret.prototype.bump = function() {
      this.forceBump = true;
      return this.update();
    };

    Caret.prototype.update = function(option) {
      var e, error;
      if (option == null) {
        option = {};
      }
      if (this.isScrolling) {
        return;
      }
      this._update();
      this.applyBlink();
      return;
      try {
        return this._update();
      } catch (error) {
        e = error;
        Logger.error("fail to update caret");
        return Logger.error(e);
      }
    };

    Caret.prototype._update = function(option) {
      var boudnary, boundary, caretLayout, ref, ref1, style, visualPosition;
      if (option == null) {
        option = {};
      }
      if (!this.cursor) {
        return;
      }
      if (!this.currentBuffer.isActive) {
        this.lastActive = false;
        return;
      }
      if (!this.currentBuffer.interactive) {
        this.hide();
        return;
      } else {
        this.show();
      }
      if (!((ref = this.currentBuffer) != null ? ref.selection.isCollapsed() : void 0) && ((ref1 = this.currentBuffer) != null ? ref1.selection.isActive : void 0)) {
        this.node.classList.add("selecting");
      } else {
        this.node.classList.remove("selecting");
      }
      if (this.currentBuffer.lockUserInput) {
        this.shape.classList.add("lock");
      } else {
        this.shape.classList.remove("lock");
      }
      if (this.lastBuffer !== this.currentBuffer || !this.lastActive || this.forceBump) {
        clearTimeout(this.bumpTimer);
        clearTimeout(this.clearTimer);
        this.shape.classList.remove("bump");
        this.shape.classList.remove("bump-minor");
        this.bumpTimer = setTimeout((function(_this) {
          return function() {
            var ref2;
            if (_this.lastRenderDetail && ((ref2 = _this.lastRenderDetail) != null ? ref2.height : void 0) > 48) {
              _this.shape.classList.add("bump-minor");
            } else {
              _this.shape.classList.add("bump");
            }
            return _this.clearTimer = setTimeout(function() {
              _this.shape.classList.remove("bump");
              return _this.shape.classList.remove("bump-minor");
            }, 100);
          };
        })(this), 10);
      }
      this.forceBump = false;
      this.lastBuffer = this.currentBuffer;
      this.lastActive = true;
      if (this.animating) {
        this.animateFrame();
      }
      if (!option.force && !this.dirty) {
        return false;
      }
      this.currentBuffer.ensureRenderContext();
      boundary = this.cursor.getBoundary();
      visualPosition = this.cursor.getVisualPosition();
      if (visualPosition) {
        while (this.dirty) {
          caretLayout = new CaretLayout(this, visualPosition);
          boudnary = caretLayout.toBoundary();
          if (boundary) {
            this.boundaryEffectTracer.updateEffect(boundary);
          }
          this.updatePosition(caretLayout);
          this.dirty = false;
        }
      }
      style = this.cursor.getStyle();
      this.applyStyle(style);
      if (this.animating) {
        return this.animateFrame();
      }
    };

    Caret.prototype.updatePosition = function(layout) {
      var renderDetail, visualPosition;
      if (!this.isActive) {
        return false;
      }
      if (!layout) {
        this.hide();
        return;
      } else {
        this.show();
      }
      visualPosition = layout.visualPosition;
      renderDetail = layout.getRenderDetail();
      if (!renderDetail) {
        return;
      }
      this.lastRenderDetail = renderDetail;
      this.currentBuffer.lastCaretRenderDetail = this.lastRenderDetail;
      if (renderDetail.type === "cover") {
        this.shape.classList.add("cover");
      } else {
        this.shape.classList.remove("cover");
      }
      this.showType = renderDetail.type;
      this.setAnimateTo(renderDetail);
      this.emit("move", renderDetail);
      this.saveBestPosition(layout);
      if (this.requestScroll && !this.editor.platform.isMobile()) {
        this.scrollViewPortToComfortable();
        this.requestScroll = false;
      }
      return this.switchingBuffer = false;
    };

    Caret.prototype.applyNodePosition = function() {
      var ps;
      ps = this.nodePosition;
      this.shape$.css({
        width: ps.width,
        height: ps.height
      });
      return this.node$.css({
        transform: "translateX(" + (Math.round(ps.left)) + "px) translateY(" + (Math.round(ps.top)) + "px)"
      });
    };

    Caret.prototype.setAnimateTo = function(targetPosition) {
      var distance, type, x, y;
      type = targetPosition.type;
      if (type === "cover@disable") {
        this.node.classList.remove("jump");
      } else {
        if (!this.nodePosition) {
          this.node.classList.add("jump");
        } else {
          x = Math.abs(targetPosition.left - this.nodePosition.left);
          y = Math.abs(targetPosition.top - this.nodePosition.top);
          distance = Math.sqrt(x * x + y * y);
          if (distance > 100 || this.switchingBuffer) {
            this.node.classList.add("jump");
          } else {
            this.node.classList.remove("jump");
          }
        }
      }
      this.nodePosition = targetPosition;
      this.applyNodePosition();
    };

    Caret.prototype.saveBestPosition = function(layout) {
      var bestX;
      if (this.currentBuffer.disableSaveBestPosition) {
        return;
      }
      bestX = layout.getCenterX();
      if (this.lastBestX !== bestX) {
        this.currentBuffer.bestCaretOffset = bestX;
        return this.lastBestX = bestX;
      }
    };

    Caret.prototype.show = function() {
      var ref;
      if (this.isShow) {
        return;
      }
      this.isShow = true;
      if (((ref = this.currentBuffer) != null ? ref.viewPort : void 0) && this.node.parentElement !== this.currentBuffer.viewPort.el) {
        this.currentBuffer.viewPort.el.appendChild(this.node);
      }
      this.VM.visibleState = "shown";
      return this.activate();
    };

    Caret.prototype.cloak = function() {
      this.show();
      return this.VM.visibleState = "cloaked";
    };

    Caret.prototype.hide = function() {
      if (!this.isShow) {
        return;
      }
      this.isShow = false;
      this.deactivate();
      return this.VM.visibleState = "hidden";
    };

    Caret.prototype.activate = function() {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      return this.applyBlink();
    };

    Caret.prototype.deactivate = function() {
      if (!this.isActive) {
        return;
      }
      this.isActive = false;
      return clearTimeout(this.blinkTimer);
    };

    Caret.prototype.applyStyle = function(style) {
      var className;
      if (style == null) {
        style = {};
      }
      className = style.className;
      if (className === this.currentClassName) {
        return false;
      }
      this.shape.classList.remove(this.currentClassName);
      this.shape.classList.add(className);
      this.currentClassName = className;
      return true;
    };

    return Caret;

  })(Leaf.Widget);

  CaretBlinkableTrait = (function(superClass) {
    extend(CaretBlinkableTrait, superClass);

    function CaretBlinkableTrait() {
      return CaretBlinkableTrait.__super__.constructor.apply(this, arguments);
    }

    CaretBlinkableTrait.prototype.initialize = function() {
      this.blinkStart = Date.now();
      return this.listenBy(CaretBlinkableTrait, "move", (function(_this) {
        return function() {
          return _this.resetBlink();
        };
      })(this));
    };

    CaretBlinkableTrait.prototype.resetBlink = function() {
      return this.blinkStart = Date.now();
    };

    CaretBlinkableTrait.prototype.shouldBlinkShow = function() {
      var hideTime, left, showTime;
      showTime = 800;
      hideTime = 500;
      left = (Date.now() - this.blinkStart) % (showTime + hideTime);
      if (left > showTime) {
        return false;
      }
      return true;
    };

    CaretBlinkableTrait.prototype.applyBlink = function() {
      if (!this.shouldBlinkShow()) {
        return this.shape.classList.add("blink-off");
      } else {
        return this.shape.classList.remove("blink-off");
      }
    };

    return CaretBlinkableTrait;

  })(Leaf.Trait);

  CaretWritableTrait = (function(superClass) {
    extend(CaretWritableTrait, superClass);

    function CaretWritableTrait() {
      return CaretWritableTrait.__super__.constructor.apply(this, arguments);
    }

    CaretWritableTrait.prototype.initialize = function() {
      return this.applyWritableListener();
    };

    CaretWritableTrait.prototype.markAsWritable = function() {
      this.unwritable = false;
      return this.shape.classList.remove("unwritable");
    };

    CaretWritableTrait.prototype.unmarkAsWritable = function() {
      this.unwritable = true;
      return this.shape.classList.add("unwritable");
    };

    CaretWritableTrait.prototype.applyWritableListener = function() {
      return this.editor.bufferManager.listenBy(this, "focus", (function(_this) {
        return function(buffer) {
          var Buffer;
          Buffer = require("./buffer");
          if (buffer instanceof Buffer.RichBuffer) {
            return _this.markAsWritable();
          } else {
            return _this.unmarkAsWritable();
          }
        };
      })(this));
    };

    return CaretWritableTrait;

  })(Leaf.Trait);

  CaretActionTrait = (function(superClass) {
    extend(CaretActionTrait, superClass);

    function CaretActionTrait() {
      return CaretActionTrait.__super__.constructor.apply(this, arguments);
    }

    CaretActionTrait.prototype.forwardChar = function() {
      var ref;
      if (!this.isActive) {
        return false;
      }
      return (ref = this.cursor) != null ? ref.conduct("forwardChar") : void 0;
    };

    CaretActionTrait.prototype.backwardChar = function() {
      var ref;
      if (!this.isActive) {
        return false;
      }
      return (ref = this.cursor) != null ? ref.conduct("backwardChar") : void 0;
    };

    CaretActionTrait.prototype.vertical = function(step) {
      var MAX, bestCursorData, bestRegion, bestX, breakDy, canBreak, counter, currentPoint, cursor, dx, dy, lastDx, moveOnce, next, previous, rd, result, startPoint, topStart, vp;
      if (!this.isActive) {
        return false;
      }
      this.currentBuffer.render();
      if (step > 0) {
        next = this.forwardChar.bind(this);
        previous = this.backwardChar.bind(this);
      } else {
        previous = this.forwardChar.bind(this);
        next = this.backwardChar.bind(this);
      }
      cursor = this.cursor;
      bestRegion = null;
      bestX = this.currentBuffer.bestCaretOffset;
      vp = this.cursor.getVisualPosition();
      if (!vp) {
        return false;
      }
      rd = CaretLayout.getRenderDetail(this, vp);
      topStart = rd.top;
      startPoint = rd.center;
      if (typeof bestX === "number") {
        startPoint.x = bestX;
      }
      lastDx = null;
      counter = 0;
      MAX = 1000;
      this.cursor.startTeleport();
      while (true) {
        if (counter > MAX) {
          Logger.error("Unlimited caret move");
          return true;
        }
        result = next();
        if (!result) {
          break;
        }
        counter += 1;
        moveOnce = true;
        vp = this.cursor.getVisualPosition();
        if (!vp) {
          continue;
        }
        rd = CaretLayout.getRenderDetail(this, vp);
        if (!rd) {
          continue;
        }
        if ((rd.top - topStart) * step <= 0) {
          continue;
        }
        currentPoint = rd.center;
        dy = currentPoint.y - startPoint.y;
        if (dy * step > 0 && Math.abs(dy) - Math.abs(step) > 0) {
          if (!canBreak) {
            breakDy = dy;
            canBreak = true;
          } else {
            if (Math.abs(dy - breakDy) > Math.abs(step) && bestCursorData) {
              break;
            }
          }
        }
        if (canBreak) {
          dx = Math.abs(currentPoint.x - startPoint.x);
          if (typeof lastDx !== "number") {
            bestCursorData = this.cursor.getData();
            lastDx = dx;
          } else if (dx <= lastDx) {
            bestCursorData = this.cursor.getData();
            lastDx = dx;
          } else if (dx > lastDx) {
            break;
          }
        }
      }
      if (!bestCursorData) {
        this.cursor.endTeleport();
        return moveOnce;
      }
      this.cursor.pointAtAnchor(bestCursorData.anchor);
      this.cursor.endTeleport();
      return true;
    };

    CaretActionTrait.prototype.verticalJump = function(step) {
      var bestRegion, bestX, boundary, charCount, counter, currentPoint, cursor, dy, estimate, estimation, getDist, greedy, greedyLimit, lastDy, lastEstimation, method, minVerticalChange, moveOnce, rect, ref, region, startPoint, topStart;
      if (!this.isActive) {
        return false;
      }
      if (step > 0) {
        method = "forwardChar";
      } else {
        method = "backwardChar";
      }
      cursor = this.cursor;
      boundary = cursor.getBoundary();
      region = DOMRegion.fromBoundary(boundary);
      rect = region.getClientRect();
      topStart = rect.top;
      bestRegion = null;
      greedy = true;
      greedyLimit = 10;
      minVerticalChange = 12;
      lastEstimation = 9999999;
      bestX = this.currentBuffer.bestCaretOffset;
      if (boundary.type === "include") {
        startPoint = {
          x: typeof bestX === "number" && bestX || (rect.left + rect.right) / 2,
          y: (rect.top + rect.bottom) / 2
        };
      } else {
        startPoint = {
          x: typeof bestX === "number" && bestX || rect.left,
          y: (rect.top + rect.bottom) / 2
        };
      }
      counter = 0;
      estimate = function(base, current) {
        var dx, dy;
        dx = current.x - base.x;
        dy = current.y - base.y;
        if (Math.abs(dy) < minVerticalChange) {
          return 999999999;
        }
        return dx * dx + dy * dy;
      };
      charCount = 0;
      while (this[method]()) {
        moveOnce = true;
        boundary = this.cursor.getBoundary();
        if (!boundary) {
          break;
        }
        region = DOMRegion.fromBoundary(boundary);
        rect = region.getRect({
          top: (ref = this.viewPort) != null ? ref.el : void 0
        });
        if (!rect) {
          break;
        }
        if ((rect.top - topStart) * step <= 0) {
          continue;
        }
        getDist = function(x, y) {
          return x * x + y * y;
        };
        if (boundary.type === "include") {
          currentPoint = {
            x: (rect.left + rect.right) / 2,
            y: (rect.top + rect.bottom) / 2
          };
        } else {
          currentPoint = {
            x: rect.left,
            y: (rect.top + rect.bottom) / 2
          };
        }
        estimation = estimate(startPoint, currentPoint);
        if (estimation < lastEstimation) {
          bestRegion = region;
          lastEstimation = estimation;
          continue;
        }
        dy = currentPoint.y - startPoint.y;
        if (typeof lastDy === "number") {
          charCount += 1;
          if (charCount > 80 && bestRegion) {
            break;
          }
        }
        if (typeof lastDy !== "number") {
          if ((dy - lastDy) * step > 0) {
            counter += 1;
            lastDy = dy;
          }
        }
        if (counter > greedyLimit) {
          greedy = false;
        }
        if (!greedy && bestRegion) {
          break;
        }
      }
      if (!bestRegion) {
        return moveOnce;
      }
      cursor.setCursorByDOMRegion(bestRegion);
      return true;
    };

    CaretActionTrait.prototype.downwardChar = function() {
      var ref, result;
      if (!this.isActive) {
        return false;
      }
      if ((ref = this.cursor) != null ? ref.conduct("downwardChar") : void 0) {
        return true;
      }
      result = this.vertical(12);
      this.currentBuffer.disableSaveBestPosition = true;
      return result;
    };

    CaretActionTrait.prototype.upwardChar = function() {
      var ref, result;
      if (!this.isActive) {
        return false;
      }
      if ((ref = this.cursor) != null ? ref.conduct("upwardChar") : void 0) {
        return true;
      }
      result = this.vertical(-12);
      return this.currentBuffer.disableSaveBestPosition = true;
    };

    CaretActionTrait.prototype.write = function(value) {
      var ref, result;
      if (!this.isActive) {
        return false;
      }
      if (!this.lastWrite) {
        this.lastWrite = Date.now();
      }
      if (this.historyInterval == null) {
        this.historyInterval = 1000 * 5;
      }
      this.lastWrite = Date.now();
      result = (ref = this.cursor) != null ? ref.conduct("write", value) : void 0;
      return result;
    };

    CaretActionTrait.prototype.begin = function() {
      return this.cursor.begin();
    };

    CaretActionTrait.prototype.end = function() {
      return this.cursor.end();
    };

    return CaretActionTrait;

  })(Leaf.Trait);

  CaretViewPortPoserTrait = (function(superClass) {
    extend(CaretViewPortPoserTrait, superClass);

    function CaretViewPortPoserTrait() {
      return CaretViewPortPoserTrait.__super__.constructor.apply(this, arguments);
    }

    CaretViewPortPoserTrait.prototype.getViewPortComfortableRelation = function() {
      var bottom, rd, top;
      rd = this.currentBuffer.lastCaretRenderDetail;
      if (!rd) {
        return 0;
      }
      top = this.viewPort.scrollable.scrollTop;
      bottom = top + this.viewPort.height;
      if (rd.top - this.viewPort.comfortableMargin < top && top > 0) {
        return rd.top - this.viewPort.comfortableMargin - this.viewPort.scrollable.scrollTop;
      }
      if (rd.bottom + this.viewPort.comfortableMargin > bottom) {
        return rd.bottom + this.viewPort.comfortableMargin - this.viewPort.height - this.viewPort.scrollable.scrollTop;
      }
      return 0;
    };

    CaretViewPortPoserTrait.prototype.inViewPortComfortableZone = function() {
      var bottom, rd, top;
      rd = this.currentBuffer.lastCaretRenderDetail;
      if (!rd) {
        return false;
      }
      top = this.viewPort.scrollable.scrollTop;
      bottom = top + this.viewPort.height;
      return rd.top - this.viewPort.comfortableMargin < top && rd.bottom + this.viewPort.comfortableMargin > bottom;
    };

    CaretViewPortPoserTrait.prototype.moveToViewPortCenter = function(option) {
      var center, change, left, lr, notIncludeCenter, rect, scrollTop, top;
      if (option == null) {
        option = {};
      }
      rect = this.viewPort.el.getBoundingClientRect();
      if (!rect) {
        return;
      }
      left = (this.viewPort.buffer.bestCaretOffset || 0) + rect.left;
      top = this.viewPort.height / 2;
      change = false;
      notIncludeCenter = false;
      scrollTop = this.viewPort.scrollable.scrollTop;
      if (!this.viewPort.buffer.lastCaretRenderDetail) {
        change = true;
        notIncludeCenter = true;
      } else {
        lr = this.viewPort.buffer.lastCaretRenderDetail;
        center = scrollTop + rect.height / 2;
        if (lr.bottom < center || lr.top > center) {
          notIncludeCenter = true;
        } else {
          notIncludeCenter = false;
        }
        if (Math.abs(this.viewPort.buffer.lastCaretRenderDetail.top - (top + scrollTop)) > 30) {
          change = true;
        }
      }
      if ((notIncludeCenter && change) || option.force) {
        this.viewPort.setCursorByClientPoint(left, top);
      }
      return this.viewPort.buffer.disableSaveBestPosition = true;
    };

    CaretViewPortPoserTrait.prototype.moveToViewPortComfortableZoneLazy = function() {
      var left, move, top;
      move = this.getViewPortComfortableRelation();
      if (move === 0) {
        return false;
      }
      left = this.currentBuffer.bestCaretOffset || 0;
      if (move > 0) {
        top = this.viewPort.height - this.viewPort.comfortableMargin;
      } else {
        top = this.viewPort.comfortableMargin;
      }
      this.viewPort.setCursorByClientPoint(left, top + 10);
      return true;
    };

    CaretViewPortPoserTrait.prototype.scrollViewPortToComfortable = function(arg) {
      var center, rd, rect, ref;
      center = (arg != null ? arg : {}).center;
      rd = (ref = this.currentBuffer) != null ? ref.lastCaretRenderDetail : void 0;
      if (!rd) {
        return;
      }
      rect = {
        width: rd.width,
        height: rd.height,
        left: rd.left,
        top: rd.top,
        right: rd.left + rd.width,
        bottom: rd.top + rd.height
      };
      return this.viewPort.scrollToRectComfortableZone(rect, {
        forceCenter: rd.height > this.viewPort.height / 2 || center
      });
    };

    return CaretViewPortPoserTrait;

  })(Leaf.Trait);

  BoundaryEffectTracer = (function() {
    function BoundaryEffectTracer(caret1) {
      this.caret = caret1;
      this.name = this.caret.name || "master";
      this.affected = [];
      this.__defineSetter__("dirty", function(value) {
        if (this.caret.dirty !== value) {
          this.caret.dirty = value;
        }
        if (value) {
          return this.sessionDirty = true;
        }
      });
      this.__defineGetter__("dirty", function() {
        return this.caret.dirty;
      });
    }

    BoundaryEffectTracer.prototype.getAffectedNode = function(boundary) {
      var cDecPart, cDecs, cText, className, i, j, left, len, len1, match, next, oldAffected, prev, previous, ref, ref1, result, right;
      if (boundary.type === "include") {
        return oldAffected = [boundary.node];
      } else if (boundary.node.nodeType === boundary.node.TEXT_NODE) {
        cDecPart = boundary.node.parentElement;
        cDecs = [cDecPart];
        if (boundary.offset === 0 && (boundary.type === "left" || !boundary.type)) {
          prev = cDecPart.previousElementSibling;
          if (prev) {
            cDecs.unshift(prev);
          }
        } else if ((boundary.offset === boundary.node.length && boundary.type === "left") || (boundary.offset === boundary.node.length - 1 && boundary.type === "right")) {
          next = cDecPart.nextElementSibling;
          if (next) {
            cDecs.push(next);
          }
        }
        cText = cDecPart != null ? cDecPart.parentElement : void 0;
        if (cDecPart != null ? cDecPart.classList.contains("com-holder") : void 0) {
          return [];
        }
        if (!cText || !cText.classList.contains("com-text")) {
          return [];
        }
        result = [cDecPart];
        previous = cDecPart;
        left = cDecs[0];
        right = cDecs[cDecs.length - 1];
        while (previous = previous.previousElementSibling) {
          match = false;
          ref = previous.classList;
          for (i = 0, len = ref.length; i < len; i++) {
            className = ref[i];
            if (className.indexOf("com-inline") !== 0 && className.indexOf("com-group") !== 0) {
              continue;
            }
            if (left.classList.contains(className)) {
              match = true;
              break;
            }
            if (match) {
              break;
            }
          }
          if (!match) {
            break;
          }
          result.unshift(previous);
        }
        next = cDecPart;
        while (next = next.nextElementSibling) {
          match = false;
          ref1 = next.classList;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            className = ref1[j];
            if (className.indexOf("com-inline") !== 0) {
              continue;
            }
            if (right.classList.contains(className)) {
              match = true;
              break;
            }
            if (match) {
              break;
            }
          }
          if (!match) {
            break;
          }
          result.push(next);
        }
        return result;
      } else {
        return [];
      }
    };

    BoundaryEffectTracer.prototype.updateEffect = function(boundary) {
      var d1, d2, d3, d4, ref;
      this.sessionDirty = false;
      this.updateOverEffect(boundary);
      d1 = this.dirty;
      this.updateAdjacentEffect(boundary);
      d2 = this.dirty;
      this.updateNearbyEffect(boundary);
      d3 = this.dirty;
      this.updateKeyPathEffect(boundary);
      d4 = this.dirty;
      if (this.sessionDirty) {
        return (ref = this.caret.currentBuffer) != null ? ref.emit("resize") : void 0;
      }
    };

    BoundaryEffectTracer.prototype.updateKeyPathEffect = function(b) {
      var drop, el, i, index, item, j, k, kps, len, len1, len2, offset, ref, ref1;
      if (this.keyPathElements == null) {
        this.keyPathElements = [];
      }
      kps = [];
      b = new DOMBoundary(b);
      el = b.getTargetParent();
      while (el && el.parentElement && el.parentElement !== this.caret.currentBuffer.viewPort.el) {
        if (el.classList) {
          kps.unshift(el);
        }
        el = el.parentElement;
      }
      index = -1;
      ref = this.keyPathElements;
      for (offset = i = 0, len = ref.length; i < len; offset = ++i) {
        item = ref[offset];
        if (kps[offset] !== item) {
          break;
        }
        index = offset;
      }
      index += 1;
      drop = this.keyPathElements.splice(index);
      for (j = 0, len1 = drop.length; j < len1; j++) {
        item = drop[j];
        item.classList.remove(this.name + "-caret-key-path");
        this.dirty = true;
      }
      kps = kps.slice(index);
      for (k = 0, len2 = kps.length; k < len2; k++) {
        item = kps[k];
        this.dirty = true;
        item.classList.add(this.name + "-caret-key-path");
      }
      (ref1 = this.keyPathElements).push.apply(ref1, kps);
      return true;
    };

    BoundaryEffectTracer.prototype.updateAdjacentEffect = function(b) {
      var adjacent, ref, ref1, ref2, ref3;
      b = new DOMBoundary(b);
      adjacent = b.getAdjacentElement();
      if (adjacent.left !== this.leftAdjacent) {
        if ((ref = this.leftAdjacent) != null) {
          ref.classList.remove(this.name + "-caret-right");
        }
        if ((ref1 = adjacent.left) != null) {
          ref1.classList.add(this.name + "-caret-right");
        }
        this.leftAdjacent = adjacent.left;
        this.dirty = true;
      }
      if (adjacent.right !== this.rightAdjacent) {
        if ((ref2 = this.rightAdjacent) != null) {
          ref2.classList.remove(this.name + "-caret-left");
        }
        if ((ref3 = adjacent.right) != null) {
          ref3.classList.add(this.name + "-caret-left");
        }
        this.rightAdjacent = adjacent.right;
        return this.dirty = true;
      }
    };

    BoundaryEffectTracer.prototype.updateOverEffect = function(b) {
      var base1, base2, maxParent, node, ref, ref1, ref2, ref3;
      maxParent = 5;
      node = b.node;
      while ((node = node.parentElement) && maxParent > 0) {
        maxParent -= 1;
        if (((ref = node.classList) != null ? typeof ref.contains === "function" ? ref.contains("com-text") : void 0 : void 0) || ((ref1 = node.classList) != null ? typeof ref1.contains === "function" ? ref1.contains("com-holder") : void 0 : void 0)) {
          break;
        }
      }
      if (typeof (base1 = node.classList).contains === "function" ? base1.contains("com-holder") : void 0) {
        node = node.previousElementSibling || null;
      }
      if (!node || !(typeof (base2 = node.classList).contains === "function" ? base2.contains("com-text") : void 0)) {
        if (this.overText) {
          if ((ref2 = this.overText) != null) {
            ref2.classList.remove(this.name + "-caret-over");
          }
          this.overText = null;
          this.dirty = true;
        }
        return;
      }
      if (node === this.overText && this.overText) {
        return;
      }
      this.dirty = true;
      if ((ref3 = this.overText) != null) {
        ref3.classList.remove(this.name + "-caret-over");
      }
      this.overText = node;
      return this.overText.classList.add(this.name + "-caret-over");
    };

    BoundaryEffectTracer.prototype.updateNearbyEffect = function(boundary) {
      var i, index, item, j, k, len, len1, len2, modified, newAffected, oldAffected, results;
      oldAffected = this.affected.slice(0);
      newAffected = this.getAffectedNode(boundary);
      modified = true;
      if (oldAffected.length === newAffected.length) {
        modified = false;
        for (index = i = 0, len = newAffected.length; i < len; index = ++i) {
          item = newAffected[index];
          if (item !== oldAffected[index]) {
            modified = true;
            break;
          }
        }
      }
      this.affected = newAffected;
      if (!modified) {
        return false;
      }
      this.dirty = true;
      for (j = 0, len1 = oldAffected.length; j < len1; j++) {
        item = oldAffected[j];
        item.classList.remove(this.name + "-caret-nearby");
      }
      results = [];
      for (k = 0, len2 = newAffected.length; k < len2; k++) {
        item = newAffected[k];
        results.push(item.classList.add(this.name + "-caret-nearby"));
      }
      return results;
    };

    return BoundaryEffectTracer;

  })();

  CaretPosition = (function() {
    function CaretPosition(caret1, boundary) {
      this.caret = caret1;
      this.editor = this.caret.editor;
      this.node = boundary != null ? boundary.node : void 0;
      this.index = (boundary != null ? boundary.index : void 0) || (boundary != null ? boundary.offset : void 0);
      this.char = boundary != null ? boundary.char : void 0;
      this.boundary = boundary;
      this.type = this.boundary.type;
      this.viewPort = this.caret.viewPort || null;
    }

    CaretPosition.prototype.getRect = function(right) {
      var rect, ref;
      if (this.region == null) {
        this.region = DOMRegion.fromBoundary(this.boundary);
      }
      rect = this.region.getRect({
        top: (ref = this.viewPort) != null ? ref.el : void 0
      });
      this.caret.viewPort.resolveRect(rect);
      return rect;
    };

    return CaretPosition;

  })();

  CaretLayout = (function() {
    CaretLayout.getRenderDetail = function(caret, vp) {
      var layout;
      layout = new CaretLayout(caret, vp);
      return layout.getRenderDetail();
    };

    function CaretLayout(caret1, visualPosition1) {
      var heightExpand, widthExpand;
      this.caret = caret1;
      this.visualPosition = visualPosition1;
      widthExpand = 0;
      heightExpand = 0;
    }

    CaretLayout.prototype.getRenderDetail = function() {
      var height, heightExpand, i, item, left, leftFix, len, orders, rd, rect, top, topFix, type, valid, vp, width, widthExpand;
      vp = this.visualPosition;
      widthExpand = 0;
      heightExpand = 0;
      topFix = 0;
      leftFix = 0;
      width = 2;
      if (vp.center) {
        orders = ["center"];
      } else if (vp.right && vp.priority === "right") {
        orders = ["right", "left"];
      } else {
        orders = ["left", "right"];
      }
      valid = false;
      for (i = 0, len = orders.length; i < len; i++) {
        item = orders[i];
        if (item === "center") {
          if (!vp.center) {
            continue;
          }
          rect = this.getCenterRect();
          if (!rect) {
            continue;
          }
          width = rect.width;
          height = rect.height;
          top = rect.top;
          left = rect.left;
          heightExpand = 4;
          widthExpand = 4;
          type = "cover";
          valid = true;
          break;
        } else if (item === "right") {
          if (!vp.right) {
            continue;
          }
          rect = this.getRightRect();
          if (!rect) {
            continue;
          }
          height = rect.height;
          heightExpand = Math.min(height * 0.3, 4);
          if (vp.right.position === "right") {
            left = rect.right;
          } else {
            left = rect.left;
          }
          top = rect.top;
          type = "caret";
          valid = true;
          break;
        } else if (item === "left") {
          if (!vp.left) {
            continue;
          }
          rect = this.getLeftRect();
          if (!rect) {
            continue;
          }
          height = rect.height;
          heightExpand = Math.min(height * 0.3, 4);
          if (vp.left.position === "right") {
            left = rect.right;
          } else {
            left = rect.left;
          }
          top = rect.top;
          type = "caret";
          valid = true;
          break;
        }
      }
      if (!valid) {
        return null;
      }
      leftFix = -widthExpand / 2;
      topFix = -heightExpand / 2;
      rd = {
        height: height + heightExpand,
        width: width + widthExpand,
        top: top + topFix,
        left: left + leftFix,
        type: type
      };
      rd.bottom = rd.top + rd.height;
      rd.right = rd.left + rd.width;
      rd.__defineGetter__("center", (function(_this) {
        return function() {
          return rd.center = {
            y: (rd.top + rd.bottom) / 2,
            x: (rd.left + rd.right) / 2
          };
        };
      })(this));
      return rd;
    };

    CaretLayout.prototype.getCenterX = function() {
      var ref, ref1;
      return (ref = this.getRenderDetail()) != null ? (ref1 = ref.center) != null ? ref1.x : void 0 : void 0;
    };

    CaretLayout.prototype.equalTo = function(target) {
      return this.rectIdentical(this.getCenterRect(), target.getCenterRect()) && this.rectIdentical(this.getLeftRect(), target.getLeftRect()) && this.rectIdentical(this.getRightRect(), target.getRightRect());
    };

    CaretLayout.prototype.rectIdentical = function(a, b) {
      var i, len, prop, props;
      if (!a && !b) {
        return true;
      }
      if (a && b) {
        props = ["left", "right", "top", "bottom"];
        for (i = 0, len = props.length; i < len; i++) {
          prop = props[i];
          if (parseInt(a[prop]) !== parseInt(b[prop])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };

    CaretLayout.prototype.getCenterRect = function() {
      var vp;
      vp = this.visualPosition;
      if (!vp.center) {
        return null;
      }
      return this.centerRect || (this.centerRect = this._getBorderRect(vp.center));
    };

    CaretLayout.prototype.getLeftRect = function() {
      var vp;
      vp = this.visualPosition;
      if (!vp.left) {
        return null;
      }
      return this.leftRect || (this.leftRect = this._getBorderRect(vp.left));
    };

    CaretLayout.prototype.getRightRect = function() {
      var vp;
      vp = this.visualPosition;
      if (!vp.right) {
        return null;
      }
      return this.rightRect || (this.rightRect = this._getBorderRect(vp.right));
    };

    CaretLayout.prototype._getBorderRect = function(border) {
      var rect, ref, region;
      region = new DOMRegion(border.node, border.offset);
      rect = region.getRect({
        top: (ref = this.caret.viewPort) != null ? ref.el : void 0
      });
      if (!rect) {
        return null;
      }
      return rect;
    };

    CaretLayout.prototype.toBoundary = function() {
      var vp;
      vp = this.visualPosition;
      if (vp.center) {
        return new DOMBoundary({
          node: vp.center.node,
          offset: vp.center.offset,
          type: "include"
        });
      } else if (vp.left) {
        return new DOMBoundary({
          node: vp.left.node,
          offset: vp.left.offset,
          type: "right"
        });
      } else if (vp.right) {
        return new DOMBoundary({
          node: vp.right.node,
          offset: vp.right.offset,
          type: "left"
        });
      }
    };

    return CaretLayout;

  })();

  Caret.CaretPosition = CaretPosition;

  module.exports = Caret;

}).call(this);

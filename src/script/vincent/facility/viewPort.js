// Generated by CoffeeScript 1.10.0
(function() {
  var DOMRegion, KeyEvent, PathTracer, PointerEvent, States, ThumbControlSession, TimeFeed, TriggerStack, Vibration, ViewPort, ViewPortPointerController, ViewPortTouchController,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DOMRegion = require("../common/region");

  States = require("../common/states");

  KeyEvent = require("../common/keyEvent");

  Vibration = require("/component/vibration");

  ViewPort = (function(superClass) {
    extend(ViewPort, superClass);

    function ViewPort(buffer, el1) {
      this.buffer = buffer;
      this.el = el1;
      ViewPort.__super__.constructor.call(this);
      this.editor = this.buffer.editor;
      this.selectSession = this.buffer.selectSession;
      this.el.viewPort = this;
      this.el.buffer = this.buffer;
      this.comfortableMargin = $("body").height() / 8 || 30;
      this.__defineGetter__("isActive", (function(_this) {
        return function() {
          return _this.buffer.isActive;
        };
      })(this));
      this.__defineGetter__("height", (function(_this) {
        return function() {
          var ref;
          return ((ref = _this.el) != null ? ref.offsetHeight : void 0) || 0;
        };
      })(this));
      this.el.addEventListener("scroll", (function(_this) {
        return function() {
          return _this.emit("scroll");
        };
      })(this));
    }

    ViewPort.prototype.setRoot = function(rootElement) {
      var ref, ref1, ref2;
      if (this.rootElement === rootElement) {
        return;
      }
      if (((ref = this.rootElement) != null ? ref.parentElement : void 0) === this.el) {
        if ((ref1 = this.rootElement) != null) {
          if ((ref2 = ref1.parentElement) != null) {
            ref2.removeChild(this.rootElement);
          }
        }
      }
      if (rootElement.parentElement !== this.el) {
        this.el.appendChild(rootElement);
      }
      this.rootElement = rootElement;
      this.rootElement.classList.add("no-select");
      return this.emit("rootElement", this.rootElement);
    };

    ViewPort.prototype.init = function() {
      this.scrollable = this.el;
      if (!this.editor.platform.isMobile()) {
        return this.controller = new ViewPortPointerController(this.buffer, this);
      } else {
        return this.controller = new ViewPortTouchController(this.buffer, this);
      }
    };

    ViewPort.prototype.scrollToRectComfortableZone = function(rect, option) {
      var bottom, center, setScroll, top;
      if (option == null) {
        option = {};
      }
      if (!rect) {
        return false;
      }
      top = this.scrollable.scrollTop;
      bottom = top + this.height;
      center = (rect.top + rect.bottom) / 2;
      setScroll = (function(_this) {
        return function(v) {
          if (_this.scrollable.scrollTop !== v) {
            return _this.scrollable.scrollTop = v;
          }
        };
      })(this);
      if (option.forceCenter) {
        this.scrollable.scrollTop = center - this.height / 2;
        return true;
      }
      if (rect.top - this.comfortableMargin < top && top > 0) {
        if (option.center) {
          setScroll(center - this.height / 2);
        } else {
          setScroll(rect.top - this.comfortableMargin);
        }
      }
      if (rect.bottom + this.comfortableMargin > bottom) {
        if (option.center) {
          setScroll(center - this.height / 2);
        } else {
          setScroll(rect.bottom + this.comfortableMargin - this.height);
        }
      }
      return true;
    };

    ViewPort.prototype.nextPage = function() {
      this.scrollable.scrollTop += this.height * 3 / 4;
      return true;
    };

    ViewPort.prototype.previousPage = function() {
      this.scrollable.scrollTop -= this.height * 3 / 4;
      return true;
    };

    ViewPort.prototype.goTop = function() {
      return this.scrollable.scrollTop = 0;
    };

    ViewPort.prototype.goBottom = function() {
      return this.scrollable.scrollTop = this.scrollable.scrollHeight;
    };

    ViewPort.prototype.DOMRegionFromPoint = function(x, y) {
      var clientX, clientY, r;
      clientX = x;
      clientY = y;
      if (this.editor.platform.isSafari()) {
        this.rootElement.classList.add("has-select");
        r = DOMRegion.fromClientPoint(x, y);
        this.rootElement.classList.remove("has-select");
      } else {
        r = DOMRegion.fromClientPoint(x, y);
      }
      return r;
    };

    ViewPort.prototype.setCursorByClientPoint = function(x, y, cursor) {
      var el, ref, region;
      if (this.selectSession == null) {
        this.selectSession = this.buffer.selectSession;
      }
      if (this.selectSession.passive && ((ref = this.selectSession.selection) != null ? typeof ref.detect === "function" ? ref.detect() : void 0 : void 0) && !cursor) {
        return;
      }
      region = this.DOMRegionFromPoint(x, y);
      if (!region) {
        return false;
      }
      el = region.getContainerElement();
      while (el && el !== this.el) {
        if (el.getAttribute("comless")) {
          return false;
        }
        el = el.parentElement;
      }
      if (cursor == null) {
        cursor = this.buffer.cursor;
      }
      cursor.setCursorByDOMRegion(region);
      return true;
    };

    ViewPort.prototype.resolveRectWithTop = function(rect) {
      var scrollTop;
      scrollTop = this.el.scrollTop;
      if (!this.baseRect) {
        this.baseRect = this.el.getBoundingClientRect();
      }
      rect = {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        height: rect.height,
        width: rect.width
      };
      rect.top += scrollTop;
      rect.bottom += scrollTop;
      rect.top -= this.baseRect.top;
      rect.bottom -= this.baseRect.top;
      rect.left -= this.baseRect.left;
      rect.right -= this.baseRect.left;
      return rect;
    };

    ViewPort.prototype.resolveRect = function(rect) {
      var scrollTop;
      scrollTop = this.el.scrollTop;
      if (!this.baseRect) {
        this.baseRect = this.el.getBoundingClientRect();
      }
      rect = {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        height: rect.height,
        width: rect.width
      };
      rect.top -= this.baseRect.top;
      rect.bottom -= this.baseRect.top;
      rect.left -= this.baseRect.left;
      rect.right -= this.baseRect.left;
      return rect;
    };

    return ViewPort;

  })(Leaf.EventEmitter);

  PointerEvent = (function() {
    function PointerEvent(e, delta1) {
      var dD, dX, dY, i, j, len, len1, name, ref, ref1, ref2, ref3, ref4, ref5, touch, value, x, y;
      this.delta = delta1;
      if (PointerEvent.winHeight == null) {
        PointerEvent.winHeight = $(window).height();
      }
      if (PointerEvent.winWidth == null) {
        PointerEvent.winWidth = $(window).width();
      }
      PointerEvent.maxDimension = Math.max(PointerEvent.winHeight, PointerEvent.winWidth);
      this.raw = e;
      this.type = e.type;
      this.src = e.target || e.srcElement;
      this.fingerCloseDistance = 140;
      this.twoHandDistance = Math.min(PointerEvent.maxDimension / 2, 440);
      this.date = new Date();
      this.shiftKey = e.shiftKey;
      if (typeof e.clientX === "number") {
        this.x = e.clientX;
        this.y = e.clientY;
        this.distance = 0;
        this.sampling = 1;
        if (e.type === "mouseup") {
          this.done = true;
        }
      } else if (typeof e.touches !== "undefined") {
        this.touches = e.touches;
        x = 0;
        y = 0;
        ref = this.touches;
        for (i = 0, len = ref.length; i < len; i++) {
          touch = ref[i];
          x += touch.clientX;
          y += touch.clientY;
        }
        this.x = x / this.touches.length;
        this.y = y / this.touches.length;
        this.indexX = (ref1 = this.touches[0]) != null ? ref1.clientX : void 0;
        this.indexY = (ref2 = this.touches[0]) != null ? ref2.clientY : void 0;
        this.indexId = ((ref3 = this.touches[0]) != null ? ref3.identifier : void 0) || -1;
        dD = 0;
        ref4 = this.touches;
        for (j = 0, len1 = ref4.length; j < len1; j++) {
          touch = ref4[j];
          dX = touch.clientX - this.x;
          dY = touch.clientY - this.y;
          dD += Math.sqrt(dX * dX + dY * dY);
        }
        this.distance = (dD / this.touches.length) * 2;
        this.sampling = this.touches.length;
        if (this.sampling === 2) {
          this.computePointAt();
        }
        if (this.type === "touchend" && this.touches.length === 0) {
          this.done = true;
        }
        if (this.type === "touchstart" && this.touches.length === 1) {
          this.increase = false;
        } else if (this.type === "touchstart") {
          this.increase = true;
        }
      } else if (e.type === "hold" && e.via) {
        ref5 = e.via;
        for (name in ref5) {
          value = ref5[name];
          if (typeof value !== "function" && (name !== "delta" && name !== "type")) {
            this[name] = value;
          }
        }
        return;
      }
    }

    PointerEvent.prototype.noTrigger = function() {
      var el;
      el = this.src;
      while (el) {
        if (el.classList.contains("com-no-trigger")) {
          return true;
        }
        el = el.parentElement;
      }
      return false;
    };

    PointerEvent.prototype.canDrag = function() {
      var el;
      el = this.src;
      while (el) {
        if (el.dragSupport === "support" || el.getAttribute("drag-support") === "support") {
          return true;
        }
        el = el.parentElement;
      }
      return false;
    };

    PointerEvent.prototype.computePointAt = function() {
      var deg, f1, f2, forwardLength, length, p1, p2, ref, unit, v, vector;
      f1 = this.touches[0];
      f2 = this.touches[1];
      p1 = {
        x: f1.clientX,
        y: f1.clientY
      };
      p2 = {
        x: f2.clientX,
        y: f2.clientY
      };
      if (p2.x < p1.x) {
        ref = [p2, p1], p1 = ref[0], p2 = ref[1];
      }
      vector = {
        x: p1.x - p2.x,
        y: p1.y - p2.y
      };
      deg = Math.PI / 2;
      v = {
        x: vector.x * Math.cos(deg) - vector.y * Math.sin(deg),
        y: vector.y * Math.cos(deg) + vector.x * Math.sin(deg)
      };
      length = Math.sqrt(v.x * v.x + v.y * v.y);
      unit = {
        x: v.x / length,
        y: v.y / length
      };
      forwardLength = this.fingerCloseDistance / 2;
      this.pointAtX = unit.x * forwardLength + this.x;
      return this.pointAtY = unit.y * forwardLength + this.y;
    };

    PointerEvent.prototype.isFingerClose = function() {
      var isClose;
      isClose = this.distance < this.fingerCloseDistance;
      return isClose;
    };

    PointerEvent.prototype.isTwoHand = function() {
      var isTwoHand;
      isTwoHand = this.distance > this.twoHandDistance;
      return isTwoHand;
    };

    PointerEvent.prototype.debugString = function() {
      return "x:" + this.x + ",y:" + this.y + ",sample:" + this.sampling + ",done:" + this.done + ",increase:" + this.increase;
    };

    PointerEvent.prototype.deltaTo = function(p) {
      return {
        x: this.x - p.x,
        y: this.y - p.y
      };
    };

    PointerEvent.prototype.distanceTo = function(p, option) {
      var dX, dY;
      if (option == null) {
        option = {};
      }
      if (option.index) {
        dX = p.indexY - this.indexY;
        dY = p.indexY - this.indexY;
      } else {
        dX = p.x - this.x;
        dY = p.y - this.y;
      }
      return Math.sqrt(dX * dX + dY * dY);
    };

    PointerEvent.prototype.capture = function() {
      var base, base1;
      if (typeof (base = this.raw).preventDefault === "function") {
        base.preventDefault();
      }
      return typeof (base1 = this.raw).stopImmediatePropagation === "function" ? base1.stopImmediatePropagation() : void 0;
    };

    return PointerEvent;

  })();

  TriggerStack = (function() {
    function TriggerStack() {
      this.actions = [];
      this.continuousFloor = 300;
    }

    TriggerStack.prototype.clear = function(left) {
      if (left > 0) {
        return this.actions = this.actions.slice(-left);
      } else {
        return this.actions.length = 0;
      }
    };

    TriggerStack.prototype.feed = function(p) {
      var date;
      date = new Date;
      date.p = p;
      if (this.actions.length > 0 && !this.near(p, this.actions[this.actions.length - 1].p)) {
        this.clear();
      }
      return this.actions.push(date);
    };

    TriggerStack.prototype.near = function(p1, p2) {
      return p1.distanceTo(p2) < 20;
    };

    TriggerStack.prototype.consume = function() {
      var current, old, previous;
      if (this.actions.length > 3) {
        this.actions = this.actions.slice(-3);
      }
      while (this.actions.length < 3) {
        this.actions.unshift(0);
      }
      current = this.actions[2];
      previous = this.actions[1];
      old = this.actions[0];
      if (current - previous > this.continuousFloor) {
        return 1;
      } else if (previous - old > this.continuousFloor) {
        return 2;
      } else {
        return 3;
      }
    };

    return TriggerStack;

  })();

  ViewPortPointerController = (function(superClass) {
    extend(ViewPortPointerController, superClass);

    function ViewPortPointerController(buffer, viewPort) {
      var lastPointDate, pt;
      this.buffer = buffer;
      this.viewPort = viewPort;
      ViewPortPointerController.__super__.constructor.call(this);
      this.triggerStack = new TriggerStack();
      this.selectSession = this.buffer.selectSession;
      this.editor = this.buffer.editor;
      lastPointDate = null;
      pt = (function(_this) {
        return function(e) {
          var delta;
          if (e.which !== 1) {
            return;
          }
          if (_this.buffer.lockUserInput) {
            return;
          }
          if (!_this.buffer.interactive) {
            return;
          }
          if (lastPointDate == null) {
            lastPointDate = new Date();
          }
          delta = new Date() - lastPointDate;
          lastPointDate = new Date();
          e = new PointerEvent(e, delta);
          _this.data.currentX = e.x;
          _this.data.currentY = e.y;
          _this.viewPort.emit("hasInteraction", e);
          return _this.give("pointer", e);
        };
      })(this);
      this.viewPort.scrollable.addEventListener("mousedown", pt);
      this.viewPort.scrollable.addEventListener("mouseup", pt);
      this.viewPort.scrollable.addEventListener("mousemove", pt);
      this.setState("idle");
    }

    ViewPortPointerController.prototype.reset = function() {
      ViewPortPointerController.__super__.reset.call(this);
      return this.resetSelection();
    };

    ViewPortPointerController.prototype.resetSelection = function() {
      return this.selectSession.clear();
    };

    ViewPortPointerController.prototype.reform = function() {
      this.reset();
      return this.setState("idle");
    };

    ViewPortPointerController.prototype.atPanic = function() {
      Logger.error(this.panicError, this.panicState);
      this.reset();
      return this.setState("idle");
    };

    ViewPortPointerController.prototype.atIdle = function() {
      var base;
      if ((base = this.data).rev == null) {
        base.rev = 0;
      }
      this.data.dragging = false;
      return this.waitFor("pointer", function(p) {
        this.data.p = p;
        if (p.type === "mousedown") {
          this.data.rev += 1;
          return this.setState("initMousedown");
        } else if (p.type === "mousemove") {
          if (this.editor.platform.isMouseDown) {
            this.selectSession.selection.deactivate();
            return this.setState("initMousemove");
          } else {
            return this.setState("idle");
          }
        } else {
          this.resetSelection();
          return this.setState("idle");
        }
      });
    };

    ViewPortPointerController.prototype.atInitMousedown = function() {
      var el, p, ref, trigger;
      p = this.data.p;
      el = p.src;
      if (p.noTrigger()) {
        this.setState("idle");
        return;
      }
      if (p.canDrag()) {
        this.data.dragging = true;
      }
      if (!this.data.dragging) {
        while (el) {
          if (((ref = el.com) != null ? ref.trigger : void 0) && el.com.transactTrigger({
            via: "mouse"
          })) {
            p.capture();
            this.resetSelection();
            this.selectSession.clearDomSelection();
            this.viewPort.setCursorByClientPoint(p.x, p.y);
            this.selectSession.selection.collapseToCursor();
            this.selectSession.selection.activate();
            this.setState("idle");
            return;
          }
          el = el.parentElement;
        }
      }
      this.triggerStack.feed(p);
      trigger = this.triggerStack.consume();
      p.capture();
      if (trigger === 2) {
        this.setState("handleDoubleDown");
        return;
      } else if (trigger === 3) {
        this.setState("handleTrippleDown");
        return;
      }
      if (!p.shiftKey) {
        this.selectSession.clearDomSelection();
      } else {
        this.selectSession.selection.activate();
      }
      this.viewPort.setCursorByClientPoint(p.x, p.y);
      if (!p.shiftKey) {
        this.selectSession.selection.collapseToCursor();
      }
      this.selectSession.selection.activate();
      return this.setState("waitInitMouseup");
    };

    ViewPortPointerController.prototype.atWaitInitMouseup = function() {
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          _this.data.p = p;
          if (p.type === "mousemove") {
            return _this.setState("initMousemove");
          } else if (p.type === "mouseup") {
            return _this.setState("initMouseup");
          } else {
            _this.resetSelection();
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortPointerController.prototype.atInitMousemove = function() {
      var p;
      p = this.data.p;
      this.viewPort.setCursorByClientPoint(p.x, p.y);
      if (this.data.dragging) {
        this.selectSession.selection.collapseToCursor();
        this.selectSession.selection.deactivate();
        this.selectSession.clearDomSelection();
      }
      return this.setState("waitInitMouseup");
    };

    ViewPortPointerController.prototype.atInitMouseup = function() {
      var p;
      p = this.data.p;
      if (p.noTrigger()) {
        this.setState("idle");
      }
      if (!this.buffer.isFocusing) {
        this.buffer.editor.bufferManager.focusAt(this.buffer);
      }
      if (this.data.dragging) {
        this.selectSession.selection.collapseToCursor();
      }
      if (this.selectSession.selection.isCollapsed()) {
        this.selectSession.selection.deactivate();
      }
      p.capture();
      return this.setState("idle");
    };

    ViewPortPointerController.prototype.atHandleDoubleDown = function() {
      if (this.selectSession.selection.isCollapsed() || !this.selectSession.isActive) {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentWord();
        this.setState("consumeVoidMouseup");
      } else {
        this.setState("consumeVoidMouseup");
      }
      return this.previousDoubleRev = this.data.rev;
    };

    ViewPortPointerController.prototype.atHandleTrippleDown = function() {
      var pt;
      pt = this.data.previousTrippleRev;
      this.data.previousTrippleRev = this.data.rev;
      if (this.data.rev - 1 === pt && !this.data.multiTripple) {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentWord();
        this.data.multiTripple = true;
      } else {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentLine();
        this.data.multiTripple = false;
      }
      return this.setState("consumeVoidMouseup");
    };

    ViewPortPointerController.prototype.atConsumeVoidMouseup = function() {
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          if (p.type === "mouseup") {
            return _this.setState("idle");
          } else if (p.type === "mousemove") {
            return _this.setState("consumeVoidMouseup");
          } else {
            _this.resetSelection();
            return _this.setState("idle");
          }
        };
      })(this));
    };

    return ViewPortPointerController;

  })(Leaf.States);

  TimeFeed = (function() {
    function TimeFeed(controller) {
      this.controller = controller;
      this.feedInterval = 100;
    }

    TimeFeed.prototype.start = function(template) {
      if (this.isStart) {
        return;
      }
      this.template = template;
      this.isStart = true;
      this.lastDate = new Date();
      if (this.rev == null) {
        this.rev = 0;
      }
      return this.timer = setInterval((function(_this) {
        return function() {
          var delta, hp;
          if (!_this.isStart) {
            _this.stop();
            return;
          }
          delta = new Date() - _this.lastDate;
          hp = new PointerEvent({
            type: "hold",
            via: _this.template
          }, delta);
          hp.rev = _this.rev;
          _this.controller.give("pointer", hp);
          _this.lastDate = new Date();
          return _this.rev += 1;
        };
      })(this), this.feedInterval);
    };

    TimeFeed.prototype.stop = function() {
      this.isStart = false;
      return clearTimeout(this.timer);
    };

    return TimeFeed;

  })();

  PathTracer = (function() {
    function PathTracer() {
      this.path = [];
      this.__defineGetter__("length", (function(_this) {
        return function() {
          return _this.path.length;
        };
      })(this));
      this.__defineGetter__("duration", (function(_this) {
        return function() {
          return _this.last.date.getTime() - _this.first.date.getTime();
        };
      })(this));
      this.__defineGetter__("maxFinger", (function(_this) {
        return function() {
          var i, item, len, ref, sampling;
          sampling = 0;
          ref = _this.path;
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            if (item.sampling > sampling) {
              sampling = item.sampling;
            }
          }
          return sampling;
        };
      })(this));
      this.__defineGetter__("finalVector", (function(_this) {
        return function() {
          var x, y;
          x = _this.last.indexX - _this.first.indexX;
          y = _this.last.indexY - _this.first.indexY;
          return {
            x: x,
            y: y
          };
        };
      })(this));
      this.__defineGetter__("monotonicX", (function(_this) {
        return function() {
          var _diff, diff, i, index, item, len, prev, ref;
          diff = 0;
          ref = _this.path;
          for (index = i = 0, len = ref.length; i < len; index = ++i) {
            item = ref[index];
            prev = _this.path[index - 1];
            if (!prev) {
              continue;
            }
            _diff = item.indexX - diff.indexX;
            if (diff === 0) {
              diff = _diff;
            } else if (diff * _diff < 0) {
              return false;
            }
          }
          return true;
        };
      })(this));
      this.__defineGetter__("monotonicY", (function(_this) {
        return function() {
          var _diff, diff, i, index, item, len, prev, ref;
          diff = 0;
          ref = _this.path;
          for (index = i = 0, len = ref.length; i < len; index = ++i) {
            item = ref[index];
            prev = _this.path[index - 1];
            if (!prev) {
              continue;
            }
            _diff = item.indexY - diff.indexY;
            if (diff === 0) {
              diff = _diff;
            } else if (diff * _diff < 0) {
              return false;
            }
          }
          return true;
        };
      })(this));
      this.__defineGetter__("monotonic", (function(_this) {
        return function() {
          return _this.monoticX && _this.monoticY;
        };
      })(this));
      this.__defineGetter__("first", (function(_this) {
        return function() {
          return _this.path[0];
        };
      })(this));
      this.__defineGetter__("last", (function(_this) {
        return function() {
          return _this.path[_this.path.length - 1];
        };
      })(this));
    }

    PathTracer.prototype.push = function(p) {
      return this.path.push(p);
    };

    PathTracer.prototype.clear = function() {
      return this.path.length = 0;
    };

    return PathTracer;

  })();

  ViewPortTouchController = (function(superClass) {
    extend(ViewPortTouchController, superClass);

    function ViewPortTouchController(buffer, viewPort) {
      var lastPointDate, pt;
      this.buffer = buffer;
      this.viewPort = viewPort;
      ViewPortTouchController.__super__.constructor.call(this);
      this.editor = this.buffer.editor;
      this.pathTracer = new PathTracer();
      this.triggerStack = new TriggerStack();
      this.selectSession = this.buffer.selectSession;
      this.timeFeed = new TimeFeed(this);
      this.antiShakeDistance = 5;
      this.holdLimit = 800;
      this.maxSwipeDuration = 500;
      lastPointDate = null;
      pt = (function(_this) {
        return function(e) {
          var delta;
          if (_this.buffer.lockUserInput) {
            return;
          }
          if (!_this.buffer.interactive) {
            return;
          }
          if (lastPointDate == null) {
            lastPointDate = new Date();
          }
          delta = new Date() - lastPointDate;
          lastPointDate = new Date();
          e = new PointerEvent(e, delta);
          _this.data.currentX = e.x;
          _this.data.currentY = e.y;
          if (_this.data.touchSession) {
            if (_this.data.touchSession.maxSampling < e.sampling || !_this.data.touchSession.maxSampling) {
              _this.data.touchSession.maxSampling = e.sampling;
            }
            _this.data.touchSession.currentSampling = e.sampling;
          }
          _this.viewPort.emit("hasInteraction", e);
          return _this.give("pointer", e);
        };
      })(this);
      this.thumbControlSession = new ThumbControlSession(this.viewPort);
      this.viewPort.scrollable.addEventListener("touchstart", pt);
      this.viewPort.scrollable.addEventListener("touchend", pt);
      this.viewPort.scrollable.addEventListener("touchmove", pt);
      this.viewPort.scrollable.addEventListener("touchcancel", pt);
      this.setState("idle");
    }

    ViewPortTouchController.prototype.reform = function() {
      this.reset();
      return this.setState("idle");
    };

    ViewPortTouchController.prototype.atPanic = function() {
      this.reset();
      this.setState("idle");
      return Logger.error("ERROR " + this.panicState + " " + (this.panicError.toString()));
    };

    ViewPortTouchController.prototype.reset = function() {
      ViewPortTouchController.__super__.reset.call(this);
      this.thumbControlSession.reset();
      return this.resetSelection();
    };

    ViewPortTouchController.prototype.resetSelection = function() {
      return this.selectSession.clear();
    };

    ViewPortTouchController.prototype.handleTouchmove = function() {
      var antiShakeX, antiShakeY, deltaLimitLeft, deltaLimitTop, p, ref, sp;
      p = this.data.movePoint;
      sp = ((ref = p.touches) != null ? ref.length : void 0) || 0;
      if (this.data.touchSession.maxSampling > 1) {
        p.capture();
      }
      if (this.data.touchSession.maxSampling > 2) {
        return;
      }
      if (!sp || sp < 2) {
        return;
      }
      if (sp === 2 || true) {
        p.capture();
        deltaLimitTop = 1500;
        deltaLimitLeft = 220;
        antiShakeX = 20;
        antiShakeY = 40;
        if (p.isFingerClose()) {
          this.data.baseTwoHandPoint = null;
          this.viewPort.setCursorByClientPoint(p.pointAtX, p.pointAtY);
        } else if (p.isTwoHand() || true) {
          this.thumbControlSession.feed("point", p);
          return;
        } else {
          this.data.baseTwoHandPoint = null;
          this.viewPort.setCursorByClientPoint(p.x, p.y);
        }
        this.thumbControlSession.reset();
      } else if (sp === 3) {

      }
    };

    ViewPortTouchController.prototype.log = function(name, message, time) {
      if (time == null) {
        time = 3000;
      }
      if (typeof message === "undefined") {
        message = name;
        name = "Default";
      }
      if (typeof message === "undefined") {
        return;
      }
      return require("/app").site.editor.plugin("HintManager").hint(name, message, {
        persist: false,
        type: "warning",
        time: time
      });
    };

    ViewPortTouchController.prototype.atIdle = function() {
      var base;
      this.timeFeed.stop();
      if ((base = this.data).rev == null) {
        base.rev = 0;
      }
      this.pathTracer.clear();
      this.thumbControlSession.reset();
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          _this.data.p = p;
          _this.data.baseTwoHandPoint = null;
          if (p.type === "touchstart" && _this.handleSideTap(p)) {
            _this.setState("idle");
            return;
          }
          if (p.type === "touchstart") {
            _this.data.rev += 1;
            _this.data.holdTime = 0;
            _this.data.touchSession = {};
            return _this.setState("initTouchstart");
          } else {
            p.capture();
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortTouchController.prototype.atInitTouchstart = function() {
      this.timeFeed.stop();
      this.timeFeed.start(this.data.p);
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          if (p.type === "hold") {
            _this.data.holdTime += p.delta;
            if (_this.data.holdTime > _this.holdLimit) {
              _this.data.holdTime = 0;
              return _this.setState("longPress");
            } else {
              return _this.setState("initTouchstart");
            }
          } else if (p.type === "touchmove") {
            if ((p.distanceTo(_this.data.p)) < _this.antiShakeDistance) {
              return _this.setState("initTouchstart");
            } else {
              _this.data.movePoint = p;
              _this.data.startPoint = _this.data.p;
              _this.pathTracer.clear();
              return _this.setState("initTouchmove");
            }
          } else if (p.type === "touchend") {
            if (p.done) {
              _this.data.startPoint = _this.data.p;
              _this.data.endPoint = p;
              return _this.setState("tap");
            } else {
              return _this.setState("initTouchstart");
            }
          } else if (p.type === "touchcancel") {
            if (p.done) {
              return _this.setState("idle");
            } else {
              return _this.setState("initTouchstart");
            }
          } else if (p.type === "touchstart") {
            if (!p.increase) {
              _this.data.p = p;
              return _this.setState("initTouchstart");
            } else {
              _this.data.startPoint = _this.data.p;
              _this.data.movePoint = p;
              return _this.setState("initTouchmove");
            }
          } else {
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortTouchController.prototype.atInitTouchmove = function() {
      if (this.data.movePoint) {
        this.pathTracer.push(this.data.movePoint);
      }
      this.timeFeed.stop();
      if (this.data.movePoint) {
        this.timeFeed.start(this.data.movePoint);
      }
      this.handleTouchmove();
      return this.waitFor("pointer", (function(_this) {
        return function(p) {
          if (p.type === "touchmove" || (p.type === "touchstart" && p.increase)) {
            if (_this.data.touchSession.maxSampling > 1) {
              p.capture();
            }
            _this.data.movePoint = p;
            return _this.setState("initTouchmove");
          } else if (p.type === "touchcancel") {
            if (p.done) {
              return _this.setState("idle");
            } else {
              return _this.setState("idle");
            }
          } else if (p.type === "touchend") {
            if (p.done && _this.data.movePoint.distanceTo(_this.data.startPoint, {
              index: true
            }) < _this.antiShakeDistance) {
              _this.data.endPoint = p;
              return _this.setState("tap");
            } else if (p.done && _this.pathTracer.maxFinger === 1 && _this.pathTracer.length > 2 && _this.pathTracer.duration < _this.maxSwipeDuration) {
              _this.data.endPoint = p;
              return _this.setState("swipe");
            } else if (p.done) {
              return _this.setState("idle");
            } else {
              _this.data.movePoint = p;
              return _this.setState("initTouchmove");
            }
          } else if (p.type === "hold") {
            _this.data.movePoint = p;
            return _this.setState("initTouchmove");
          } else if (p.type === "touchstart") {
            _this.data.p = p;
            return _this.setState("initTouchstart");
          } else {
            return _this.setState("idle");
          }
        };
      })(this));
    };

    ViewPortTouchController.prototype.atTap = function() {
      var e, el, error, ref, ref1, ref2, ref3, trigger;
      el = this.data.startPoint.src;
      if (((ref = this.data.touchSession.maxSampling) !== 1 && ref !== 3) && this.data.touchSession.maxSampling) {
        this.setState("idle");
        return;
      }
      if ((ref1 = this.data.endPoint) != null) {
        ref1.capture();
      }
      if (this.data.touchSession.maxSampling === 3) {
        this.resetSelection();
        this.setState("idle");
        return;
      }
      this.triggerStack.feed(this.data.startPoint);
      trigger = this.triggerStack.consume();
      if (trigger === 1 && this.handleSideTap(this.data.startPoint)) {
        this.triggerStack.clear(0);
        this.setState("idle");
        return;
      }
      if (trigger === 1) {
        this.selectSession.selection.deactivate();
        this.viewPort.setCursorByClientPoint(this.data.startPoint.x, this.data.startPoint.y);
        return this.setState("idle");
      } else if (trigger === 2) {
        try {
          if (!this.data.startPoint.noTrigger()) {
            while (el && !(this.data.touchSession.maxSampling > 1)) {
              if ((ref2 = el.com) != null ? ref2.trigger : void 0) {
                Vibration.feedback();
                if (el.com.transactTrigger({
                  via: "tap"
                })) {
                  if ((ref3 = this.data.endPoint) != null) {
                    ref3.capture();
                  }
                  this.resetSelection();
                  this.setState("idle");
                  return;
                }
              }
              el = el.parentElement;
            }
          }
        } catch (error) {
          e = error;
          this.log("ERROR " + (e.toString()));
        }
        return this.setState("idle");
      } else if (trigger === 3) {
        this.triggerStack.clear(0);
        return this.setState("idle");
      }
    };

    ViewPortTouchController.prototype.atSwipe = function() {
      var e, error;
      this.minSwipeX = 100;
      this.minSwipeY = 100;
      try {
        if (this.pathTracer.finalVector.x > this.minSwipeX) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeRight"
          }));
        } else if (this.pathTracer.finalVector.x < -this.minSwipeX) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeLeft"
          }));
        }
        if (this.pathTracer.finalVector.y > this.minSwipeY) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeDown"
          }));
        } else if (this.pathTracer.finalVector.y < -this.minSwipeY) {
          this.editor.inputMethod.emit("key", new KeyEvent({
            simulateName: "swipeUp"
          }));
        }
      } catch (error) {
        e = error;
        this.log(Math.random(), "error " + (JSON.stringify(e.message)), 1000);
      }
      this.pathTracer.clear();
      return this.setState("idle");
    };

    ViewPortTouchController.prototype.atLongPress = function() {
      if (!this.selectSession.selection.isActive) {
        this.viewPort.setCursorByClientPoint(this.data.p.x, this.data.p.y);
        this.selectSession.selectCurrentWord();
      } else {
        this.selectSession.selection.deactivate();
      }
      Vibration.feedback();
      return this.setState("idle");
    };

    ViewPortTouchController.prototype.handleSideTap = function(p) {
      var e, error;
      if (this.clientWidth == null) {
        this.clientWidth = $(window).width();
      }
      if (this.sideTapLimit == null) {
        this.sideTapLimit = 30;
      }
      try {
        if (p.x < this.sideTapLimit) {
          this.editor.conduct("backward-char");
          return true;
        }
        if (p.x > this.clientWidth - this.sideTapLimit) {
          this.editor.conduct("forward-char");
          return true;
        }
      } catch (error) {
        e = error;
        Logger.error("error " + e.message + " " + e.name);
      }
      return false;
    };

    return ViewPortTouchController;

  })(Leaf.States);

  ThumbControlSession = (function(superClass) {
    extend(ThumbControlSession, superClass);

    function ThumbControlSession(viewPort) {
      this.viewPort = viewPort;
      ThumbControlSession.__super__.constructor.call(this);
      this.editor = this.viewPort.editor;
      this.stepX = 5;
      this.stepY = 10;
      this.xFloor = 4;
      this.yFloor = 12;
      this.offsetXScale = 1.7;
      this.offsetYScale = 2.2;
      this.offsetXAtiShake = 0;
      this.offsetYAtiShake = 0;
    }

    ThumbControlSession.prototype.reset = function() {
      ThumbControlSession.__super__.reset.call(this);
      return this.setState("waitFirstPoint");
    };

    ThumbControlSession.prototype.atWaitFirstPoint = function() {
      return this.consumeWhenAvailable("point", (function(_this) {
        return function(p) {
          _this.data.startPoint = p;
          _this.viewPort.setCursorByClientPoint(p.x, p.y);
          _this.lastPointDate = new Date();
          return _this.setState("waitMovePoint");
        };
      })(this));
    };

    ThumbControlSession.prototype.atWaitMovePoint = function() {
      return this.consumeWhenAvailable("point", (function(_this) {
        return function(p) {
          _this.distributeCommandByPoint(p);
          return _this.setState("waitMovePoint");
        };
      })(this));
    };

    ThumbControlSession.prototype.distributeCommandByPoint = function(p) {
      var dx, dy, fdx, fdy, fx, fy, px, py;
      dx = p.x - this.data.startPoint.x;
      dy = p.y - this.data.startPoint.y;
      if (dx >= 0) {
        fx = 1;
      } else {
        fx = -1;
      }
      if (dy >= 0) {
        fy = 1;
      } else {
        fy = -1;
      }
      fdx = (dx - this.offsetXAtiShake * fx) * this.offsetXScale;
      fdy = (dy - this.offsetYAtiShake * fy) * this.offsetYScale;
      if (fdx * fx > 0) {
        px = fdx + this.data.startPoint.x;
      } else {
        px = this.data.startPoint.x;
      }
      if (fdy * fy > 0) {
        py = fdy + this.data.startPoint.y;
      } else {
        py = this.data.startPoint.y;
      }
      if (px !== this.data.startPoint.x || py !== this.data.startPoint.y) {
        return this.viewPort.setCursorByClientPoint(px, py);
      }
    };

    ThumbControlSession.prototype.distributeCommandByPointVelocity = function(p) {
      var dT, dvx, dvy, dx, dy;
      if (!this.data.lastPoint) {
        this.data.lastPoint = this.data.startPoint;
        this.data.lastDate = this.data.lastPoint.date;
      }
      if (p.type === "hold") {
        p = this.data.lastPoint;
      }
      dT = Date.now() - this.data.lastDate.getTime();
      if (dT === 0) {
        return;
      }
      dx = (p.x + this.data.lastPoint.x) / 2 - this.data.startPoint.x;
      dy = (p.y + this.data.lastPoint.y) / 2 - this.data.startPoint.y;
      dvx = dx * dT / 1000;
      dvy = dy * dT / 1000;
      this.accumulateX(dvx);
      this.accumulateY(dvy);
      this.data.lastPoint = p;
      return this.data.lastDate = new Date;
    };

    ThumbControlSession.prototype.distributeCommandByPointAboluste = function() {
      var countX, countY, dx, dy;
      dx = p.x - this.data.startPoint.x;
      dy = p.y - this.data.startPoint.y;
      countX = Math.round(dx / this.stepX);
      countY = Math.round(dy / this.stepY);
      this.applyVerticle(countY);
      return this.applyHorizental(countX);
    };

    ThumbControlSession.prototype.accumulateX = function(value) {
      var base, results;
      if ((base = this.data).xValue == null) {
        base.xValue = 0;
      }
      this.data.xValue += value;
      while (this.data.xValue > this.xFloor) {
        this.data.xValue -= this.xFloor;
        this.right();
      }
      results = [];
      while (this.data.xValue < -this.xFloor) {
        this.data.xValue += this.xFloor;
        results.push(this.left());
      }
      return results;
    };

    ThumbControlSession.prototype.accumulateY = function(value) {
      var base, results;
      if ((base = this.data).yValue == null) {
        base.yValue = 0;
      }
      this.data.yValue += value;
      while (this.data.yValue > this.yFloor) {
        this.data.yValue -= this.yFloor;
        this.down();
      }
      results = [];
      while (this.data.yValue < -this.yFloor) {
        this.data.yValue += this.yFloor;
        results.push(this.up());
      }
      return results;
    };

    ThumbControlSession.prototype.applyVerticle = function(count) {
      var base, down, results;
      if ((base = this.data).currentVertical == null) {
        base.currentVertical = 0;
      }
      down = count - this.data.currentVertical;
      while (down > this.data.currentVertical) {
        this.down();
        this.data.currentVertical += 1;
      }
      results = [];
      while (down < this.data.currentVertical) {
        this.up();
        results.push(this.data.currentVertical -= 1);
      }
      return results;
    };

    ThumbControlSession.prototype.applyHorizental = function(count) {
      var base, results, right;
      if ((base = this.data).currentHorizental == null) {
        base.currentHorizental = 0;
      }
      right = count - this.data.currentHorizental;
      while (right > this.data.currentHorizental) {
        this.right();
        this.data.currentHorizental += 1;
      }
      results = [];
      while (right < this.data.currentHorizental) {
        this.left();
        results.push(this.data.currentHorizental -= 1);
      }
      return results;
    };

    ThumbControlSession.prototype.down = function() {
      return this.editor.conduct("downward-char");
    };

    ThumbControlSession.prototype.up = function() {
      return this.editor.conduct("upward-char");
    };

    ThumbControlSession.prototype.right = function() {
      return this.editor.conduct("forward-char");
    };

    ThumbControlSession.prototype.left = function() {
      return this.editor.conduct("backward-char");
    };

    return ThumbControlSession;

  })(Leaf.States);

  module.exports = ViewPort;

}).call(this);

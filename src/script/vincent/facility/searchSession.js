// Generated by CoffeeScript 1.10.0
(function() {
  var Rune, SearchSession, Walker;

  Walker = COM.COMWalker;

  Rune = COM.COMRune;

  SearchSession = (function() {
    function SearchSession(buffer1) {
      this.buffer = buffer1;
      this.editor = this.buffer.editor;
      this.modifier = "gi";
      this.lightColor = "yellow";
      this.focusColor = "orange";
    }

    SearchSession.prototype.setKeyword = function(keyword) {
      this.end();
      return this.keyword = keyword;
    };

    SearchSession.prototype.applyCurrent = function(option) {
      var item, selection;
      if (option == null) {
        option = {};
      }
      item = this.currentFocus;
      selection = this.buffer.selection;
      if (!item) {
        selection.deactivate();
      } else if (option.begin) {
        selection.baseCursor.pointAtAnchor(item.startAnchor);
        selection.extentCursor.pointAtAnchor(item.startAnchor);
        return selection.deactivate();
      } else if (option.select) {
        selection.activate();
        selection.baseCursor.pointAtAnchor(item.startAnchor);
        return selection.extentCursor.pointAtAnchor(item.endAnchor);
      } else {
        selection.baseCursor.pointAtAnchor(item.endAnchor);
        selection.extentCursor.pointAtAnchor(item.endAnchor);
        return selection.deactivate();
      }
    };

    SearchSession.prototype.buildReg = function() {
      var mod, word;
      if (this.keyword.indexOf("reg:") === 0) {
        word = this.keyword.slice(4).replace(/\\n/g, "\n");
        mod = "g";
      } else {
        word = this.keyword.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, function(match) {
          return "\\" + match;
        });
        mod = this.modifier;
      }
      return new RegExp(word, mod);
    };

    SearchSession.prototype.search = function() {
      var buffer, context, cs, currentNode, currentNodePass, cursor, end, endAnchor, match, nextHit, node, previousHit, previousHitTarget, ref, ref1, reg, result, results, start, startAnchor, walker;
      buffer = this.buffer;
      context = this.buffer.context;
      walker = new Walker.WalkerRootFirst(context);
      walker.setNode(context.root);
      results = [];
      currentNode = false;
      nextHit = null;
      previousHit = null;
      reg = this.buildReg();
      previousHitTarget = null;
      cursor = this.cursorBackup;
      while (walker.next((function(item) {
          return item.sortOf("RichText");
        }))) {
        reg.lastIndex = 0;
        node = walker.node;
        cs = Rune.purifyContentString(node.contentString, {
          useHolder: true
        });
        if (walker.node === cursor.target) {
          currentNodePass = true;
        }
        while (match = reg.exec(cs)) {
          if (match[0].length === 0) {
            break;
          }
          startAnchor = walker.node.anchor.clone();
          endAnchor = walker.node.anchor.clone();
          start = match.index;
          end = match.index + match[0].length;
          startAnchor.index = start;
          endAnchor.index = end;
          result = {
            target: walker.node,
            content: match[0],
            length: match.length,
            start: start,
            end: end,
            startAnchor: startAnchor,
            endAnchor: endAnchor
          };
          if (currentNodePass && !nextHit && !this.isReverse) {
            if (result.target === cursor.target && result.start >= cursor.anchor.index) {
              nextHit = true;
              result.current = true;
            } else if (result.target !== cursor.target) {
              nextHit = true;
              result.current = true;
            }
          }
          if (this.isReverse && !currentNodePass) {
            previousHit = true;
            previousHitTarget = result;
          } else if (this.isReverse && currentNodePass && result.target === cursor.target && result.end <= cursor.anchor.index) {
            previousHit = true;
            previousHitTarget = result;
          } else if (this.isReverse && !previousHit) {
            previousHit = true;
            previousHitTarget = result;
          }
          results.push(result);
        }
      }
      if (previousHitTarget) {
        previousHitTarget.current = true;
      }
      if (!nextHit && !this.isReverse) {
        if ((ref = results[0]) != null) {
          ref.current = true;
        }
      }
      if (!previousHitTarget && this.isReverse) {
        if ((ref1 = results[results.length - 1]) != null) {
          ref1.current = true;
        }
      }
      return results;
    };

    SearchSession.prototype.start = function() {
      var current, i, item, len, light, ref;
      if (this.isStart) {
        return;
      }
      this.isStart = true;
      this.cursorBackup = this.buffer.cursor.clone();
      this.lightSession = this.buffer.highlighter.createSession();
      this.hits = this.search();
      this.lights = [];
      this.lightSession.clear();
      ref = this.hits;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        light = this.lightSession.addHighlight(item.startAnchor, item.endAnchor, {
          color: this.lightColor
        });
        item.light = light;
        if (item.current) {
          current = item;
        }
      }
      this.lightSession.applyAll();
      if (current) {
        return this.setCurrent(current);
      }
    };

    SearchSession.prototype.end = function(option) {
      var ref;
      if (option == null) {
        option = {};
      }
      if (!this.isStart) {
        return;
      }
      this.isStart = false;
      if (option.apply && this.keyword) {
        this.applyCurrent(option);
      } else if ((ref = this.cursorBackup) != null ? ref.anchor : void 0) {
        this.buffer.selection.deactivate();
        this.buffer.cursor.pointAtAnchor(this.cursorBackup.anchor);
        this.buffer.selection.collapseToCursor();
      }
      if (this.lightSession) {
        this.lightSession.clear();
        return this.lightSession = null;
      }
    };

    SearchSession.prototype.replaceAll = function(content) {
      this.buffer.context.transact((function(_this) {
        return function() {
          var hit, i, len, ref, text;
          ref = _this.hits;
          for (i = 0, len = ref.length; i < len; i++) {
            hit = ref[i];
            if (!hit) {
              continue;
            }
            text = hit.light.startCursor.target;
            hit.light.startCursor.anchor.deleteBetween(hit.light.endCursor.anchor);
            text.insertText(hit.light.startCursor.anchor.index, content);
          }
          return _this.hits = [];
        };
      })(this));
      return true;
    };

    SearchSession.prototype.replaceCurrentContentAndNext = function(content) {
      if (!this.currentFocus) {
        return false;
      }
      return this.buffer.context.transact((function(_this) {
        return function() {
          var matchIndex, text;
          text = _this.currentFocus.light.startCursor.target;
          _this.currentFocus.light.startCursor.anchor.deleteBetween(_this.currentFocus.light.endCursor.anchor);
          text.insertText(_this.currentFocus.light.startCursor.anchor.index, content);
          matchIndex = -1;
          _this.currentFocus.light.clear();
          _this.hits = _this.hits.filter(function(item, index) {
            if (item !== _this.currentFocus) {
              return true;
            }
            matchIndex = index;
            return false;
          });
          if (_this.hits[matchIndex]) {
            return _this.setCurrent(_this.hits[matchIndex]);
          } else if (_this.hits[0]) {
            return _this.setCurrent(_this.hits[0]);
          } else {
            return _this.currentFocus = null;
          }
        };
      })(this));
    };

    SearchSession.prototype.setCurrent = function(item) {
      var rect, ref;
      if (!item) {
        return false;
      }
      if (this.currentFocus) {
        this.currentFocus.light.setOption({
          color: this.lightColor
        });
      }
      item.light.setOption({
        color: this.focusColor
      });
      this.currentFocus = item;
      this.buffer.cursor.pointAtAnchor(item.light.startCursor.anchor);
      item.light.blink();
      rect = (ref = item.light.rects[0]) != null ? ref.rect : void 0;
      if (!rect) {
        return;
      }
      this.editor.buffer.viewPort.scrollToRectComfortableZone(rect, {
        forceCenter: true
      });
      return true;
    };

    SearchSession.prototype.next = function() {
      var i, index, item, len, next, ref;
      if (!this.hits) {
        return false;
      }
      if (!this.currentFocus) {
        return this.setCurrent(this.hits[0]);
      }
      ref = this.hits;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        next = this.hits[index + 1];
        if (item === this.currentFocus) {
          if (next) {
            this.setCurrent(next);
            return true;
          } else {
            return this.setCurrent(this.hits[0]);
          }
        }
      }
      return false;
    };

    SearchSession.prototype.previous = function() {
      var i, index, item, len, previous, ref;
      if (!this.hits) {
        return false;
      }
      if (!this.currentFocus) {
        return this.setCurrent(this.hits[0]);
      }
      ref = this.hits;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        previous = this.hits[index - 1];
        if (item === this.currentFocus) {
          if (previous) {
            this.setCurrent(previous);
            return true;
          } else {
            return this.setCurrent(this.hits[this.hits.length - 1]);
          }
        }
      }
      return false;
    };

    return SearchSession;

  })();

  module.exports = SearchSession;

}).call(this);

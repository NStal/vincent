// Generated by CoffeeScript 1.10.0
(function() {
  var COMComposer, COMContainer, COMContents, COMRichText, ContentsAvoidEmpty, ContentsAvoidNested, MergeByComposePolicy, NormalizeRichTexts,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  COMComposer = require("./composer");

  COMRichText = require("./richText");

  COMContainer = require("./container");

  COMContents = (function(superClass) {
    extend(COMContents, superClass);

    COMContents.prototype.type = "Contents";

    function COMContents(context, data) {
      this.context = context;
      this.data = data;
      if (this.appearance == null) {
        this.appearance = {
          tagName: "div",
          classList: ["com", "com-contents"]
        };
      }
      COMContents.__super__.constructor.call(this, this.context, this.data);
    }

    COMContents.prototype.render = function(rc) {
      return COMContents.__super__.render.call(this, rc, {
        recursive: true,
        selfless: !this.beforeMark("hasAttachedChild") && !this.beforeMark("hasDetachedChild")
      });
    };

    return COMContents;

  })(COMContainer);

  ContentsAvoidNested = (function(superClass) {
    extend(ContentsAvoidNested, superClass);

    function ContentsAvoidNested() {
      return ContentsAvoidNested.__super__.constructor.apply(this, arguments);
    }

    ContentsAvoidNested.prototype.type = "Contents";

    ContentsAvoidNested.prototype.exec = function() {
      var child, children, i, index, item, j, len, once, toAppend;
      children = this.target.children.slice();
      for (index = i = 0, len = children.length; i < len; index = ++i) {
        item = children[index];
        if (item.sortOf("Contents") || item.sortOf("Root")) {
          once = true;
          toAppend = item.children.slice();
          item.empty();
          for (j = toAppend.length - 1; j >= 0; j += -1) {
            child = toAppend[j];
            item.after(child);
          }
          item.remove();
        }
      }
      return once || false;
    };

    return ContentsAvoidNested;

  })(COMComposer);

  ContentsAvoidEmpty = (function(superClass) {
    extend(ContentsAvoidEmpty, superClass);

    function ContentsAvoidEmpty() {
      return ContentsAvoidEmpty.__super__.constructor.apply(this, arguments);
    }

    ContentsAvoidEmpty.prototype.type = "Contents";

    ContentsAvoidEmpty.prototype.exec = function() {
      var last, node;
      last = this.target.last();
      if (!last) {
        node = this.context.createElement("RichText", {
          contentString: ""
        });
        this.target.append(node);
        return true;
      }
    };

    return ContentsAvoidEmpty;

  })(COMComposer);

  NormalizeRichTexts = (function(superClass) {
    extend(NormalizeRichTexts, superClass);

    function NormalizeRichTexts() {
      return NormalizeRichTexts.__super__.constructor.apply(this, arguments);
    }

    NormalizeRichTexts.prototype.type = "Contents";

    NormalizeRichTexts.prototype.exec = function() {
      var anchor, children, contents, currentJoins, cursor, i, index, item, j, joined, k, l, last, len, len1, len2, len3, ref, ref1, ref2, ref3, ref4, ref5, ref6, removed, renderTarget;
      children = this.target.children.slice();
      if ((ref = window.perf) != null) {
        ref.start("L1");
      }
      for (i = 0, len = children.length; i < len; i++) {
        item = children[i];
        index = this.target.indexOf(item);
        if (children.length > 1 && item.length === 0) {
          if ((ref1 = window.perf) != null) {
            ref1.start("AC");
          }
          ref2 = item.anchors;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            anchor = ref2[j];
            cursor = anchor.cursor;
            cursor.next({
              actions: ["head"]
            }) || cursor.previous({
              actions: ["tail"]
            });
          }
          if ((ref3 = window.perf) != null) {
            ref3.end("AC");
          }
          item.remove();
          removed = true;
        } else if (item.length === 0) {
          true;
        }
      }
      if ((ref4 = window.perf) != null) {
        ref4.end("L1");
      }
      currentJoins = [];
      children = this.target.children.slice();
      children.push({
        end: true
      });
      if ((ref5 = window.perf) != null) {
        ref5.start("L2");
      }
      for (index = k = 0, len2 = children.length; k < len2; index = ++k) {
        item = children[index];
        if (item.type === "RichText" && !(item.length === 0 && item === this.target.last())) {
          currentJoins.push(item);
        } else {
          if (currentJoins.length < 2) {
            currentJoins.length = 0;
            continue;
          }
          index = this.target.indexOf(currentJoins[0]);
          contents = currentJoins.map(function(item) {
            return item.contentString;
          }).join("");
          for (l = 0, len3 = currentJoins.length; l < len3; l++) {
            item = currentJoins[l];
            item.remove();
            joined = true;
          }
          renderTarget = this.context.createElement("RichText", {
            contentString: contents
          });
          this.target.insert(index, renderTarget);
          this.mergeAnchors(currentJoins, renderTarget);
          currentJoins.length = 0;
          joined = true;
        }
      }
      if ((ref6 = window.perf) != null) {
        ref6.end("L2");
      }
      last = this.target.last();
      if (!last || last.type !== "RichText") {
        this.target.append(this.context.createElement("RichText", {
          contentString: "\n"
        }));
        return true;
      }
      if (removed || joined) {
        return true;
      }
      return false;
    };

    NormalizeRichTexts.prototype.mergeAnchors = function(children, target) {
      var anchor, base, i, item, j, len, len1, ref, results;
      base = 0;
      results = [];
      for (i = 0, len = children.length; i < len; i++) {
        item = children[i];
        ref = item.anchors;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          anchor = ref[j];
          anchor.cursor.pointAt(target, {
            anchor: {
              index: base + anchor.index
            }
          });
        }
        results.push(base += item.length);
      }
      return results;
    };

    return NormalizeRichTexts;

  })(COMComposer);

  MergeByComposePolicy = (function(superClass) {
    extend(MergeByComposePolicy, superClass);

    function MergeByComposePolicy() {
      return MergeByComposePolicy.__super__.constructor.apply(this, arguments);
    }

    MergeByComposePolicy.prototype.type = "Contents";

    MergeByComposePolicy.prototype.obeys = function(a, b) {
      var ca, cb, needSplit;
      if (!a || !b) {
        return true;
      }
      needSplit = a.composePolicy.newlineSplitTail || b.composePolicy.newlineSplitHead;
      if (!needSplit) {
        return false;
      }
      ca = a.contentString;
      cb = b.contentString;
      return !ca || ca.slice(-1) === "\n" || !cb || cb[0] === "\n" || false;
    };

    MergeByComposePolicy.prototype.exec = function() {
      var afterContent, anchor, beforeContent, changed, child, childIndex, children, counter, i, index, j, len, len1, length, newText, next, ref, ref1;
      children = this.target.children.slice();
      length = children.length;
      index = 0;
      counter = 0;
      while (child = children[index]) {
        counter += 1;
        index += 1;
        next = children[index];
        if (!child || !next) {
          continue;
        }
        if (child.composerBuffer.passMerge && next.composerBuffer.passMerge) {
          continue;
        }
        if (this.obeys(child, next)) {
          continue;
        }
        beforeContent = child.contentString;
        afterContent = next.contentString;
        childIndex = this.target.indexOf(child);
        this.target.removeChild(child);
        this.target.removeChild(next);
        newText = this.context.createElement("RichText", {
          contentString: ((typeof child.toContentString === "function" ? child.toContentString() : void 0) || beforeContent) + (next.toContentString() || afterContent)
        });
        this.target.insert(childIndex, newText);
        ref = child.anchors;
        for (i = 0, len = ref.length; i < len; i++) {
          anchor = ref[i];
          anchor.cursor.pointAt(newText, {
            anchor: {
              index: anchor.index
            }
          });
        }
        ref1 = next.anchors;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          anchor = ref1[j];
          anchor.cursor.pointAt(newText, {
            anchor: {
              index: beforeContent.length + anchor.index
            }
          });
        }
        children[index] = newText;
        changed = true;
      }
      if (changed) {
        return true;
      }
      return false;
    };

    return MergeByComposePolicy;

  })(COMComposer);

  COMContents.ContentsAvoidEmpty = ContentsAvoidEmpty;

  COMContents.NormalizeRichTexts = NormalizeRichTexts;

  COMContents.MergeByComposePolicy = MergeByComposePolicy;

  module.exports = COMContents;

}).call(this);

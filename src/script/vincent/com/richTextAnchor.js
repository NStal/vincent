// Generated by CoffeeScript 1.10.0
(function() {
  var COMAnchor, COMNode, COMRichText, COMRichTextAnchor, COMVisualPosition, Errors, StringHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMNode = require("./node");

  COMRichText = require("./richText");

  StringHelper = require("./helper/string");

  COMAnchor = require("./anchor");

  Errors = require("./errors");

  COMVisualPosition = require("./visualPosition");

  COMRichTextAnchor = (function(superClass) {
    extend(COMRichTextAnchor, superClass);

    function COMRichTextAnchor(node1) {
      this.node = node1;
      COMRichTextAnchor.__super__.constructor.call(this);
      this.index = 0;
      this.rev = 0;
      this.__defineGetter__("index", (function(_this) {
        return function() {
          return _this._index;
        };
      })(this));
      this.__defineSetter__("index", (function(_this) {
        return function(value) {
          var change, length;
          if (value !== _this._index) {
            change = true;
          }
          if (value < 0) {
            value = 0;
          }
          length = _this.node.contentString.length;
          if (value > length) {
            value = length;
          }
          _this.rev += 1;
          _this._index = value;
          _this._inside = false;
          if (change) {
            _this.emit("move");
          }
          return _this._index;
        };
      })(this));
      this.__defineGetter__("inside", (function(_this) {
        return function() {
          return _this._inside;
        };
      })(this));
      this.__defineSetter__("inside", (function(_this) {
        return function(value) {
          var move;
          if (value !== _this._inside) {
            move = true;
          }
          _this._inside = value;
          if (move) {
            _this.emit("move");
          }
          return _this._inside;
        };
      })(this));
      this.index = 0;
      this.inside = false;
      return;
    }

    COMRichTextAnchor.prototype.getPath = function() {
      var path;
      path = this.node.getPath();
      path.anchor = this.toJSON();
      return path;
    };

    COMRichTextAnchor.prototype.activate = function(cursor) {
      var ref, target;
      this.cursor = cursor;
      if (indexOf.call(this.node.anchors, this) < 0) {
        this.node.anchors.push(this);
      }
      if (this.cursor.name) {
        target = "cursor-over-" + this.cursor.name;
        if (indexOf.call(this.node.appearance.classList, target) < 0) {
          this.node.appearance.classList.push(target);
        }
        return (ref = this.node.el) != null ? ref.classList.add(target) : void 0;
      }
    };

    COMRichTextAnchor.prototype.deactivate = function(arg) {
      var ref, ref1, replacementAnchor, replacementCursor, target;
      ref = arg != null ? arg : {}, replacementCursor = ref.replacementCursor, replacementAnchor = ref.replacementAnchor;
      if (this.cursor && this.cursor.name && (replacementCursor !== this.cursor || !this.equal(replacementAnchor))) {
        target = "cursor-over-" + this.cursor.name;
        if (indexOf.call(this.node.appearance.classList, target) >= 0) {
          this.node.appearance.classList = this.node.appearance.classList.filter(function(item) {
            return item !== target;
          });
        }
        if ((ref1 = this.node.el) != null) {
          ref1.classList.remove(target);
        }
      }
      this.cursor = null;
      return this.node.anchors = this.node.anchors.filter((function(_this) {
        return function(item) {
          return item !== _this;
        };
      })(this));
    };

    COMRichTextAnchor.prototype.toJSON = function() {
      return {
        index: this.index,
        inside: this.inside
      };
    };

    COMRichTextAnchor.prototype.fromJSON = function(json) {
      this.index = json.index;
      return this.inside = json.inside;
    };

    COMRichTextAnchor.prototype.forwardChar = function() {
      var rune;
      if (this.index < this.node.length) {
        rune = this.node.runeAtIndex(this.index);
        if (rune && this.cursor.trapIn(rune, {
          direction: "left"
        })) {
          return true;
        }
        if (rune) {
          if (rune.trigger && !this.inside) {
            this.inside = true;
          } else {
            this.index += rune.length;
          }
        } else {
          this.index += 1;
        }
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.backwardChar = function() {
      var rune;
      if (this.inside) {
        this.inside = false;
        return true;
      }
      if (this.index > 0) {
        rune = this.node.runeAtIndex(this.index - 1);
        if (rune && this.cursor.trapIn(rune, {
          direction: "right"
        })) {
          return true;
        }
        if (rune) {
          this.index -= rune.length;
          if (rune.trigger) {
            this.inside = true;
          }
        } else {
          this.index -= 1;
        }
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.trapRecover = function(rune, direction) {
      var i, len, ref, text;
      if (direction == null) {
        direction = "left";
      }
      this.node.reflow();
      ref = this.node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        text = ref[i];
        if (text === rune) {
          if (direction === "left") {
            this.index = rune.startOffset;
          } else {
            this.index = rune.endOffset;
          }
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.backwardWord = function() {
      var contentString, find, last, length, maybe, results, rune, start;
      if (this.index === 0) {
        return false;
      }
      this.node.reflow();
      if (this.node.isRuneAt(this.index)) {
        rune = this.node.runeAtIndex(this.index);
        if (rune.startOffset === this.index) {
          rune = null;
        }
      } else if (this.node.isRuneAt(this.index - 1)) {
        rune = this.node.runeAtIndex(this.index - 1);
      }
      if (rune) {
        this.index = rune.startOffset;
        if (this.index !== 0) {
          return true;
        }
      }
      contentString = this.node.contentString;
      find = StringHelper.findJumpBreakBackward(contentString, this.index);
      if (find.index === this.index) {
        return false;
      }
      if (rune = this.node.runeAtIndex(find)) {
        if (rune.index !== find) {
          find = rune.endOffset;
        }
      }
      this.index = find;
      return true;
      contentString = this.node.contentString;
      maybe = contentString.slice(0, this.index);
      results = maybe.split(/\b/);
      last = results.pop() || "";
      if (/^\s+$/.test(last)) {
        last = (results.pop() || "") + last;
      }
      length = last.length;
      start = maybe.length - length;
      this.index = start;
      return true;
    };

    COMRichTextAnchor.prototype.forwardWord = function() {
      var MAX, contentString, find, first, maybe, results, rune, start;
      if (this.index > this.node.length) {
        return false;
      }
      this.node.reflow();
      if (this.node.isRuneAt(this.index)) {
        rune = this.node.runeAtIndex(this.index);
      }
      if (rune) {
        this.index = rune.endOffset;
        return true;
      }
      contentString = this.node.contentString;
      find = StringHelper.findJumpBreakForward(contentString, this.index);
      if (find.index === this.index) {
        return false;
      }
      if (rune = this.node.runeAtIndex(find)) {
        if (rune.index !== find) {
          find = rune.endOffset;
        }
      }
      this.index = find;
      return true;
      MAX = null;
      contentString = this.node.contentString;
      maybe = contentString.slice(this.index);
      if (maybe.length === 0) {
        return false;
      }
      results = maybe.split(/\b/);
      first = results.shift() || "";
      while (/^\s+$/.test(first)) {
        first = (results.shift() || "") + first;
        if (results.length === 0) {
          break;
        }
      }
      start = first.length;
      if (start === 0) {
        start = maybe.length;
      }
      this.index += start;
      return true;
    };

    COMRichTextAnchor.prototype.deleteLineBeforeAnchor = function() {
      var cs, hasNewLine, index;
      cs = this.node.contentString;
      index = this.index;
      if (cs[this.index] === "\n") {
        this.index -= 1;
      }
      while (cs[this.index] !== "\n" && this.index > 0) {
        this.index -= 1;
      }
      hasNewLine = cs[this.index] === "\n";
      if (this.index === 0) {
        this.node.removeText(0, index);
      } else {
        this.node.removeText(this.index, index - this.index);
      }
      if (this.index === 0 && !hasNewLine) {
        return false;
      } else {
        return true;
      }
      return true;
    };

    COMRichTextAnchor.prototype.deleteChar = function() {
      var rune;
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        rune.remove();
        this.inside = false;
        return true;
      }
      if (this.index === 0) {
        return false;
      }
      this.node.removeText(this.index - 1, 1);
      return true;
    };

    COMRichTextAnchor.prototype.deleteWord = function() {
      var contentString, index, rune, targetIndex;
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        rune.remove();
        this.inside = false;
        return true;
      }
      if (this.index === 0) {
        return false;
      }
      contentString = this.node.contentString;
      index = this.index;
      targetIndex = StringHelper.findJumpBreakBackward(this.node.contentString, index);
      if (targetIndex === index) {
        return false;
      }
      this.node.removeText(targetIndex, index - targetIndex);
      return true;
    };

    COMRichTextAnchor.prototype.startOfLine = function(option) {
      var contentString, index;
      if (option == null) {
        option = {};
      }
      index = this.index;
      contentString = this.node.contentString;
      if (contentString[this.index - 1] === "\n") {
        this.inside = false;
        return true;
      }
      while (index > 0) {
        if (contentString[index - 1] === "\n" && !this.node.isRuneAt(index - 1)) {
          this.index = index;
          return true;
        }
        index -= 1;
      }
      if (option.begin) {
        this.index = 0;
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.endOfLine = function() {
      var contentString, index, length;
      index = this.index;
      length = this.node.length;
      contentString = this.node.contentString;
      if (contentString[this.index] === "\n") {
        return true;
      }
      while (index < length) {
        if (contentString[index + 1] === "\n" && !this.node.isRuneAt(index + 1)) {
          this.index = index + 1;
          return true;
        }
        index += 1;
      }
      return false;
    };

    COMRichTextAnchor.prototype.isTail = function() {
      return this.index === this.node.length;
    };

    COMRichTextAnchor.prototype.isHead = function() {
      return this.index === 0;
    };

    COMRichTextAnchor.prototype.head = function() {
      this.index = 0;
      return true;
    };

    COMRichTextAnchor.prototype.tail = function() {
      this.index = this.node.length;
      return true;
    };

    COMRichTextAnchor.prototype.trigger = function(option) {
      if (this.triggerChild(option)) {
        return true;
      }
      if (this.triggerSelf(option)) {
        return true;
      }
      return false;
    };

    COMRichTextAnchor.prototype.triggerSelf = function(option) {
      var base;
      if (typeof (base = this.node).trigger === "function" ? base.trigger(option) : void 0) {
        return true;
      }
    };

    COMRichTextAnchor.prototype.triggerChild = function(option) {
      var item, result;
      if (option == null) {
        option = {};
      }
      item = this.node.getChildTextByOffset(this.index);
      if (!item) {
        return false;
      }
      if (item.sortOf("Rune")) {
        if (this.inside) {
          return typeof item.trigger === "function" ? item.trigger() : void 0;
        } else {
          return false;
        }
      }
      if (item.startOffset === this.index && !option.force) {
        return false;
      }
      if (item.endOffset === this.index && !option.force) {
        return false;
      }
      if (item.startOffset === this.index && !item.trigger) {
        item = item.previous();
        if (!item || !option.force) {
          return false;
        }
      }
      return result = (typeof item.trigger === "function" ? item.trigger() : void 0) || false;
    };

    COMRichTextAnchor.prototype.getVisualPosition = function() {
      var centerBorder, cs, end, i, index, item, itemIndex, lastChar, leftBorder, len, next, offset, only, previous, ref, ref1, ref2, rightBorder, start;
      index = this.index;
      previous = null;
      offset = 0;
      cs = this.node.contentString;
      if (index === 0 && cs.length === 0) {
        if ((only = this.node.children[0]) && only.getEmptyBorder) {
          return {
            left: only.getEmptyBorder(),
            right: only.getEmptyBorder(),
            center: null
          };
        } else {
          offset = ((ref = this.node.el) != null ? (ref1 = ref.children) != null ? ref1.length : void 0 : void 0) - 1;
          return {
            left: new COMVisualPosition.COMVisualBorder({
              node: this.node.holder.parentElement,
              offset: offset,
              position: "left"
            }),
            right: new COMVisualPosition.COMVisualBorder({
              node: this.node.holder.parentElement,
              offset: offset,
              position: "right"
            }),
            center: null
          };
        }
      }
      cs = this.node.contentString;
      lastChar = cs[cs.length - 1];
      ref2 = this.node.children || [];
      for (itemIndex = i = 0, len = ref2.length; i < len; itemIndex = ++i) {
        item = ref2[itemIndex];
        previous = this.node.children[itemIndex - 1];
        next = this.node.children[itemIndex + 1];
        start = offset;
        end = offset + item.length;
        if (this.inside && item.sortOf("Rune") && index >= start && index < end) {
          leftBorder = previous != null ? previous.getVisualBorder(previous != null ? previous.length : void 0, "left") : void 0;
          centerBorder = item != null ? item.getVisualBorder(index - start, "inside") : void 0;
          rightBorder = next != null ? next.getVisualBorder(0, "right") : void 0;
          break;
        }
        if (index === 0 && start === 0) {
          leftBorder = null;
          centerBorder = null;
          rightBorder = item.getVisualBorder(0, "right");
          break;
        }
        if (index === start && index === end && item.getEmptyBorder) {
          return {
            left: only.getEmptyBorder(),
            right: only.getEmptyBorder(),
            center: null
          };
        }
        if (index >= start && index < end) {
          leftBorder = item != null ? item.getVisualBorder(index - start, "left") : void 0;
          centerBorder = null;
          rightBorder = item != null ? item.getVisualBorder(index - start, "right") : void 0;
          break;
        }
        if (index === end && !this.inside) {
          if (next && next.isEmpty() && next.getEmptyBorder) {
            leftBorder = next.getEmptyBorder();
            rightBorder = next.getEmptyBorder();
            centerBorder = null;
          } else {
            leftBorder = item.getVisualBorder(item.length, "left");
            centerBorder = null;
            rightBorder = next != null ? next.getVisualBorder(0, "right") : void 0;
          }
          break;
        }
        offset += item.length;
      }
      return new COMVisualPosition({
        left: leftBorder,
        center: centerBorder,
        right: rightBorder
      });
    };

    COMRichTextAnchor.prototype.getCorrespondingBoundary = function() {
      var i, index, item, len, offset, ref, result;
      offset = this.index;
      ref = this.node.children;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (offset > item.length) {
          offset -= item.length;
        } else if (offset === item.length) {
          if (item.sortOf("Rune") || this.inside) {
            offset -= item.length;
          } else if (item.noTailingBoundary || this.node.childNoTailingBoundary) {
            offset -= item.length;
          } else {
            result = item.getCorrespondingBoundaryByOffset(offset, {
              right: true
            });
            if (result) {
              return result;
            } else {
              offset -= item.length;
            }
          }
        } else {
          if (offset === 0 && item.sortOf("Rune") && this.inside) {
            return {
              node: item.el,
              type: "include"
            };
          }
          return item.getCorrespondingBoundaryByOffset(offset, {
            right: true
          });
        }
      }
      if (offset === 0) {
        return {
          node: this.node.holder.textNode,
          offset: 0,
          type: "left"
        };
      }
      return null;
    };

    COMRichTextAnchor.prototype.IMEReplace = function(before, after) {
      var cs, index, offset, rune, shouldBe;
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        this.index += rune.contentString.length;
      }
      cs = this.node.contentString;
      shouldBe = cs.slice(this.index - before.length, this.index);
      if (shouldBe !== before) {
        return false;
      }
      offset = 0;
      while (before[offset] && before[offset] === after[offset]) {
        offset += 1;
        continue;
      }
      before = before.slice(offset);
      after = after.slice(offset);
      index = this.index;
      if (before) {
        this.node.removeText(index - before.length, before.length);
      }
      if (after) {
        this.node.insertText(index - before.length, after);
      }
      return true;
    };

    COMRichTextAnchor.prototype.getIMEAnchor = function(string) {
      var cs, end, start;
      cs = this.node.contentString;
      if (cs.slice(this.index - string.length, this.index) === string) {
        start = this.clone();
        start.index = this.index - string.length;
        end = this.clone();
        return {
          start: start,
          end: end
        };
      }
      return {};
    };

    COMRichTextAnchor.prototype.write = function(value) {
      var rune;
      if (value == null) {
        value = null;
      }
      if (!value) {
        return false;
      }
      this.node.reflow();
      if (this.inside && (rune = this.node.runeAtIndex(this.index))) {
        this.index = rune.endOffset;
      }
      if (value instanceof COMNode && value.sortOf("Rune")) {
        this.node.insertRune(this.index, value);
        return true;
      }
      if (typeof value === "string") {
        value = value.replace(/\t/g, "").replace(/\r\n/g, "\n").replace(/[\r\b\f\v\0]/g, "");
      }
      this.node.insertText(this.index, value);
      return true;
    };

    COMRichTextAnchor.prototype.setByDOM = function(node, offset) {
      var fix, i, last, len, ref, ref1, ref2, result, text;
      if (!(typeof node instanceof Text)) {
        node = node.childNodes[offset] || node;
      }
      if (!this.node.el.contains(node)) {
        return null;
      }
      this.node.reflow();
      if (result = (ref = this.node) != null ? ref.getOffsetByDOM(node, offset) : void 0) {
        if (result) {
          this.index = result.index;
          this.inside = result.inside;
          return true;
        }
      }
      if (node === this.node.holder.textNode) {
        last = this.node.last();
        if (last != null ? last.blockTail : void 0) {
          fix = -1;
        } else {
          fix = 0;
        }
        this.index = (((ref1 = this.node.last()) != null ? ref1.endOffset : void 0) || 0) + fix;
        return true;
      }
      ref2 = this.node.children;
      for (i = 0, len = ref2.length; i < len; i++) {
        text = ref2[i];
        result = text.detectTextOffset(node, offset);
        if (result) {
          if (text.sortOf("Rune")) {
            this.index = text.startOffset;
            this.inside = true;
            return true;
          }
          this.index = text.startOffset + result.offset;
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.deleteBetween = function(anchor) {
      var end, endInside, position, rune, start, startInside;
      if (!anchor) {
        return false;
      }
      if (anchor.node !== this.node) {
        return false;
      }
      position = this.compare(anchor);
      if (position === "after") {
        return anchor.deleteBetween(this);
      }
      if (position === "identical") {
        return false;
      }
      if (position === "under") {
        return false;
      }
      if (position === "contain") {
        return false;
      }
      if (position !== "before") {
        throw new Errors.LogicError("position should be before");
      }
      start = this.index;
      end = anchor.index;
      startInside = this.inside;
      endInside = anchor.inside;
      anchor.index = this.index;
      if (endInside) {
        rune = this.node.runeAtIndex(end);
        if (rune) {
          this.node.removeText(end, 1);
        }
      }
      if (end !== start) {
        this.node.removeText(start, end - start);
      }
      if (startInside) {
        rune = this.node.runeAtIndex(start);
        if (rune) {
          this.node.removeText(start, 1);
          this.index -= rune.contentString.length;
          anchor.index -= rune.contentString.length;
        }
      }
      return true;
    };

    COMRichTextAnchor.prototype.equal = function(target) {
      if (!target) {
        return false;
      }
      return target.node === this.node && target.index === this.index && target.inside === this.inside;
    };

    COMRichTextAnchor.prototype.clone = function() {
      var anchor;
      anchor = new COMRichTextAnchor(this.node);
      anchor.index = this.index;
      anchor.inside = this.inside;
      return anchor;
    };

    COMRichTextAnchor.prototype.split = function() {
      var after;
      if (this.index === this.node.length || this.index === 0) {
        return false;
      }
      after = this.node.contentString.slice(this.index);
      this.node.removeText(this.index, this.node.length - this.index);
      this.node.after(new COMRichText(this.node.context, {
        contentString: after
      }));
      return true;
    };

    COMRichTextAnchor.prototype.previousRune = function() {
      var i, item, ref, target;
      this.node.reflow();
      target = null;
      ref = this.node.children;
      for (i = ref.length - 1; i >= 0; i += -1) {
        item = ref[i];
        if (!item.sortOf("Rune")) {
          continue;
        }
        if (item.startOffset < this.index) {
          target = item;
          this.index = item.startOffset;
          this.inside = true;
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.nextRune = function(option) {
      var i, item, len, ref;
      this.node.reflow();
      ref = this.node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (!item.trigger || item.noTriggerFocus) {
          continue;
        }
        if (item.startOffset > this.index || (item.startOffset === this.index && option.fresh)) {
          this.index = item.startOffset;
          if (item.sortOf("Rune")) {
            this.inside = true;
          }
          return true;
        } else if (item.startOffset === this.index && !this.inside && item.sortOf("Rune")) {
          this.inside = true;
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.previousRune = function() {
      var i, item, ref, target;
      this.node.reflow();
      target = null;
      ref = this.node.children;
      for (i = ref.length - 1; i >= 0; i += -1) {
        item = ref[i];
        if (!item.trigger || item.noTriggerFocus) {
          continue;
        }
        if (item.startOffset < this.index) {
          target = item;
          this.index = item.startOffset;
          if (item.sortOf("Rune")) {
            this.inside = true;
          }
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.afterRune = function(rune) {
      if (rune.parent !== this.node) {
        return false;
      }
      this.node.reflow();
      this.index = rune.startOffset + rune.length;
      return true;
    };

    COMRichTextAnchor.prototype.atRune = function(rune) {
      if (rune.parent !== this.node) {
        return false;
      }
      this.node.reflow();
      this.index = rune.startOffset;
      return this.inside = true;
    };

    COMRichTextAnchor.prototype.beforeRune = function(rune) {
      if (rune.parent !== this.node) {
        return false;
      }
      this.node.reflow();
      this.index = rune.startOffset;
      return true;
    };

    COMRichTextAnchor.prototype.compare = function(anchor) {
      var parentAnchor, position, target, targetAnchor;
      if (anchor instanceof COMAnchor && anchor.node === this.node) {
        if (this.index > anchor.index) {
          return "after";
        } else if (this.index < anchor.index) {
          return "before";
        } else if (this.index === anchor.index) {
          return "identical";
        }
        return null;
      } else if (!(anchor instanceof COMAnchor)) {
        if (anchor.leftMost) {
          if (this.leftMost) {
            return "identical";
          } else {
            return "after";
          }
        } else if (anchor.rightMost) {
          if (this.rightMost) {
            return "identical";
          } else {
            return "before";
          }
        }
        return null;
      }
      position = this.node.compareNodePosition(anchor.node);
      if (!position) {
        return null;
      }
      if (position === "before") {
        return "before";
      }
      if (position === "after") {
        return "after";
      }
      if (position === "identical") {
        throw new Errors.LogicError("can't have anchor has identical path but point to different node");
      }
      if (position === "under") {
        target = this.node;
        while (target.parent !== anchor.node && target) {
          target = target.parent;
        }
        if (!target) {
          throw new Errors.Logic("node.compare returns under but find no common parent");
        }
        parentAnchor = target.parent.anchor.clone();
        parentAnchor.pointAt(target);
        parentAnchor.inside = true;
        if (parentAnchor.index > anchor.index) {
          return "after";
        } else if (parentAnchor.index < anchor.index) {
          return "before";
        } else if (parentAnchor.inside && !anchor.index) {
          return "after";
        } else if (!parentAnchor.inside && anchor.inside) {
          return "before";
        } else {
          return "under";
        }
      }
      if (position === "contain") {
        target = anchor.node;
        while (target && target.parent !== this.node) {
          target = target.parent;
        }
        if (!target) {
          throw new Errors.LogicError("node.compare returns contain but find no common parent");
        }
        targetAnchor = target.parent.anchor.clone();
        targetAnchor.pointAt(target);
        targetAnchor.inside = true;
        if (this.index > targetAnchor.index) {
          return "after";
        } else if (this.index < targetAnchor.index) {
          return "before";
        } else if (this.inside && !targetAnchor.index) {
          return "after";
        } else if (!this.inside && targetAnchor.inside) {
          return "before";
        } else {
          return "contain";
        }
      } else {
        throw new Errros.LogicError("unexpected node compare turn " + position);
      }
    };

    COMRichTextAnchor.prototype.pointAt = function(target) {
      var i, item, len, ref;
      this.node.reflow();
      ref = this.node.children;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (target === item) {
          this.index = target.startOffset;
          if (target.sortOf("Rune")) {
            this.inside = true;
          }
          return true;
        }
      }
      return false;
    };

    COMRichTextAnchor.prototype.getCaretStyle = function() {
      return this.node.caretStyle || null;
    };

    COMRichTextAnchor.prototype.matchingBeforeText = function(string) {
      var cs;
      cs = this.node.contentString;
      return cs.slice(this.index - string.length, this.index) === string;
    };

    COMRichTextAnchor.prototype.getSurroundingWord = function(count) {
      var afterContent, afterCount, beforeContent, beforeCount, char, charReg, cs, index;
      if (count == null) {
        count = 5;
      }
      if (this.inside) {
        return null;
      }
      cs = this.node.contentString;
      index = this.index;
      beforeCount = count;
      afterCount = count;
      charReg = /[a-z'"]/i;
      while (beforeCount > 0) {
        char = cs[index - 1];
        if (char === " ") {
          while (cs[index - 1] === " ") {
            index -= 1;
          }
          beforeCount -= 1;
          continue;
        }
        if (!char || !charReg.test(char)) {
          break;
        }
        index -= 1;
      }
      if (index < 0) {
        index = 0;
      }
      beforeContent = cs.slice(index, this.index);
      index = this.index;
      while (afterCount > 0) {
        char = cs[index];
        if (char === " ") {
          while (cs[index] === " ") {
            index -= 1;
          }
          afterCount -= 1;
          continue;
        }
        if (!char || !charReg.test(char)) {
          break;
        }
        index += 1;
      }
      afterContent = cs.slice(this.index, index);
      return {
        before: beforeContent,
        after: afterContent
      };
    };

    COMRichTextAnchor.prototype.getSurroundingText = function(count) {
      var after, before, cs, start;
      if (count == null) {
        count = 5;
      }
      if (this.inside) {
        return null;
      }
      cs = this.node.contentString;
      start = this.index - count;
      if (start < 0) {
        start = 0;
      }
      before = cs.slice(start, this.index);
      after = cs.slice(this.index, this.index + count);
      return {
        before: before,
        after: after
      };
    };

    return COMRichTextAnchor;

  })(COMAnchor);

  module.exports = COMRichTextAnchor;

}).call(this);

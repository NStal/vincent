// Generated by CoffeeScript 1.10.0
(function() {
  var COMPath;

  COMPath = (function() {
    COMPath.fromNode = function(node) {
      var path, ref, routes;
      routes = [];
      while (node.parent) {
        routes.push(node.parent.indexOf(node));
        node = node.parent;
      }
      path = new COMPath({
        type: "COMPath",
        routes: routes
      });
      path.anchor = ((ref = node.anchor) != null ? typeof ref.toJSON === "function" ? ref.toJSON() : void 0 : void 0) || null;
      return path;
    };

    COMPath.prototype.type = "COMPath";

    function COMPath(node) {
      var base;
      if (node == null) {
        node = {};
      }
      if (node.leftMost) {
        this.leftMost = true;
      } else if (node.rightMost) {
        this.rightMost = true;
      }
      this.routes = [];
      if (node.isCOMObject) {
        while (node.parent) {
          this.routes.push(node.parent.indexOf(node));
          node = node.parent;
        }
        if (node.anchor) {
          this.anchor = (typeof (base = node.anchor).toJSON === "function" ? base.toJSON() : void 0) || null;
        }
      } else if (node instanceof COMPath) {
        this.routes = node.getRoutes();
        this.anchor = node.anchor;
      } else if (node.type === "COMPath") {
        this.routes = node.routes || [];
        this.anchor = node.anchor || null;
      } else {
        this.routes = [];
        this.anchor = null;
      }
    }

    COMPath.prototype.getRoutes = function() {
      return this.routes.slice();
    };

    COMPath.prototype.toJSON = function() {
      return {
        routes: this.routes,
        type: "COMPath",
        leftMost: this.leftMost,
        rightMost: this.rightMost
      };
    };

    COMPath.prototype.compare = function(b) {
      var a, asub, bsub, pa, pb;
      if (this.leftMost) {
        if (b.leftMost) {
          return "identical";
        } else {
          return "before";
        }
      } else if (this.rightMost) {
        if (b.rightMost) {
          return "identical";
        } else {
          return "after";
        }
      }
      a = this;
      if (a === b) {
        return "identical";
      }
      pa = a.getRoutes();
      pb = b.getRoutes();
      while (typeof (asub = pa.pop()) === "number") {
        bsub = pb.pop();
        if (asub === bsub) {
          continue;
        } else if (typeof bsub !== "number") {
          return "under";
        } else if (asub > bsub) {
          return "after";
        } else if (asub < bsub) {
          return "before";
        }
      }
      if (typeof pb.pop() === "number") {
        return "contain";
      }
      return "identical";
    };

    return COMPath;

  })();

  module.exports = COMPath;

}).call(this);

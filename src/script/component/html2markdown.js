// Generated by CoffeeScript 1.10.0
(function() {
  var DomEl, HTMLParser, HTMLStack, _stack, flatten, htmlEntity, toMarkdown,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  HTMLParser = require("./htmlparser");

  htmlEntity = require("./htmlEntity");

  DomEl = (function() {
    function DomEl(name1, attrs, children) {
      var i, item, len;
      this.name = name1;
      if (attrs == null) {
        attrs = [];
      }
      this.children = children != null ? children : [];
      this.attrs = [];
      this.contentLength = 0;
      for (i = 0, len = attrs.length; i < len; i++) {
        item = attrs[i];
        this.attrs[item.name] = item.value;
      }
      this.name = this.name.toUpperCase();
    }

    DomEl.prototype.push = function(child) {
      child.parent = this;
      return this.children.push(child);
    };

    return DomEl;

  })();

  HTMLStack = (function() {
    function HTMLStack() {
      this.__defineGetter__("tag", (function(_this) {
        return function() {
          return _this.stack[_this.stack.length - 1];
        };
      })(this));
      this.__defineGetter__("indentString", (function(_this) {
        return function() {
          return _this.getIndentSpace(_this.indent);
        };
      })(this));
      this.inlineTags = ["a", "img", "bold", "strong", "font", "center", "italic", "span", "b", "em"];
      this.singleLineTags = ["h1", "h2", "h3", "h4", "h5", "h6", "li"];
      this.multiLineTags = ["code", "pre"];
      this.orderTags = ["li"];
      this.singleLineSplit = ["blockquote"];
      this.indentTags = ["ul", "ol"];
      this.ignoreTags = ["script", "link", "template", "meta", "header", "title", "br", "base"];
    }

    HTMLStack.prototype.escapeMarkdownUrl = function(string) {
      var _map, result;
      if (string == null) {
        string = "";
      }
      _map = {
        "(": "\\(",
        ")": "\\)",
        "\\": "\\\\"
      };
      result = string.replace(/\(|\)|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };

    HTMLStack.prototype.escapeMarkdownUrlContent = function(string) {
      var _map, result;
      if (string == null) {
        string = "";
      }
      if (/^!\[.*\]\(.*\)$/.test(string)) {
        return string.replace(/\n/g, "");
      }
      _map = {
        "[": "\\[",
        "]": "\\]",
        "\\": "\\\\"
      };
      result = string.replace(/\[|\]|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };

    HTMLStack.prototype.createTagData = function(tag, attrs, unary) {
      var _, count, data, headline, i, item, j, len, ref, url;
      for (i = 0, len = attrs.length; i < len; i++) {
        item = attrs[i];
        attrs[item.name] = item.value;
      }
      data = {
        name: tag,
        attrs: attrs,
        unary: unary,
        childTexts: [],
        children: [],
        transformContent: function(str) {
          return str;
        },
        decorationBefore: "",
        decorationAfter: "",
        marks: [],
        containMarks: function(marks) {
          var j, len1, mark;
          if (marks == null) {
            marks = [];
          }
          for (j = 0, len1 = marks.length; j < len1; j++) {
            mark = marks[j];
            if (indexOf.call(this.marks, mark) >= 0) {
              return true;
            }
          }
          return false;
        }
      };
      if (indexOf.call(this.inlineTags, tag) >= 0) {
        data.inline = true;
      } else if (indexOf.call(this.ignoreTags, tag) >= 0) {
        data.ignore = true;
      } else if (indexOf.call(this.indentTags, tag) >= 0) {
        data.indent = true;
      } else if (indexOf.call(this.singleLineTags, tag) >= 0) {
        data.singleLine = true;
      } else if (indexOf.call(this.multiLineTags, tag) >= 0) {
        data.multiLine = true;
      } else {
        data.raw = true;
      }
      if (tag === "a") {
        url = this.escapeMarkdownUrl(data.attrs.href);
        data.decorationBefore = function() {
          if (data.containMarks(["h1", "h2", "h3", "h4", "h5", "h6", "a", "li", "ul", "ol", "code", "pre", "li", "blockquote", "img"])) {
            return "";
          } else {
            return " [";
          }
        };
        data.decorationAfter = function(content, length) {
          if (data.containMarks(["h1", "h2", "h3", "h4", "h5", "h6", "a", "li", "ul", "ol", "code", "pre", "li", "blockquote", "img"])) {
            return "";
          } else {
            return "](" + url + ") ";
          }
        };
        data.transformContent = (function(_this) {
          return function(content, length) {
            if (data.containMarks(["h1", "h2", "h3", "h4", "h5", "h6", "a", "li", "ul", "ol", "code", "pre", "li", "blockquote", "img"])) {
              return content;
            }
            return _this.escapeMarkdownUrlContent(content);
          };
        })(this);
      }
      if (tag === "img") {
        if (!data.attrs.src) {
          data.markdownString = "";
        } else {
          data.markdownString = "![" + (this.escapeMarkdownUrlContent(data.attrs.alt || data.attrs.title || "")) + "](" + (this.escapeMarkdownUrl(data.attrs.src || "")) + ")";
        }
      }
      if (tag === "li") {
        data.decorationBefore = function(content) {
          if (content == null) {
            content = "";
          }
          if (content.trim().length === 0) {
            return "";
          } else {
            return "* ";
          }
        };
        data.transformContent = function(str) {
          return str.replace(/\n/, "");
        };
      }
      if (tag === "blockquote") {
        data.decorationBefore = "> ";
      }
      if (tag === "h1" || tag === "h2" || tag === "h3" || tag === "h4" || tag === "h5" || tag === "h6") {
        count = parseInt(tag[1]) || 1;
        headline = "";
        for (_ = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; _ = 0 <= ref ? ++j : --j) {
          headline += "#";
        }
        data.decorationBefore = headline + " ";
      }
      if (tag === "pre" || tag === "code") {
        data.decorationBefore = (function(_this) {
          return function() {
            if (data.containMarks(["code", "pre"])) {
              return "";
            } else {
              return "```\n";
            }
          };
        })(this);
        data.decorationAfter = (function(_this) {
          return function() {
            if (data.containMarks(["code", "pre"])) {
              return "";
            } else {
              return "\n```";
            }
          };
        })(this);
        data.transformContent = function(str) {
          if (str == null) {
            str = "";
          }
          if (data.containMarks(["code", "pre"])) {
            return str;
          } else {
            return str.replace(/```/g, "\\`\\`\\`");
          }
        };
      }
      return data;
    };

    HTMLStack.prototype.getIndentSpace = function(n) {
      var item;
      if (n == null) {
        n = 0;
      }
      return ((function() {
        var i, ref, results;
        results = [];
        for (item = i = 0, ref = n; 0 <= ref ? i < ref : i > ref; item = 0 <= ref ? ++i : --i) {
          results.push("    ");
        }
        return results;
      })()).join("");
    };

    HTMLStack.prototype.markAncestor = function(name) {
      var i, item, len, ref, results;
      ref = this.stack;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (indexOf.call(item.marks, name) < 0) {
          results.push(item.marks.push(name));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    HTMLStack.prototype.parse = function(html) {
      this.indent = 0;
      this.stack = [];
      this.disabledTagNames = ["script", "link", "style", "meta", "template", "header"];
      this.indentTagNames = ["ul", "ol"];
      this.stack.push(this.createTagData("root", [], false));
      HTMLParser(html, {
        start: (function(_this) {
          return function(tag, attrs, unary) {
            var data;
            tag = tag.toLowerCase();
            data = _this.createTagData(tag, attrs, unary);
            _this.tag.children.push(data);
            _this.markAncestor(tag);
            if (unary) {
              return _this.tag.childTexts.push(data.markdownString || "");
            } else {
              return _this.stack.push(data);
            }
          };
        })(this),
        end: (function(_this) {
          return function(tag) {
            var after, before, content, text;
            content = _this.tag.transformContent(_this.tag.childTexts.join(""));
            before = "";
            after = "";
            if (typeof _this.tag.decorationBefore === "function") {
              before = _this.tag.decorationBefore(content, _this.tag.childTexts, _this.tag.childTexts);
            } else if (typeof _this.tag.decorationBefore === "string") {
              before = _this.tag.decorationBefore;
            }
            if (typeof _this.tag.decorationAfter === "function") {
              after = _this.tag.decorationAfter(content, _this.tag.childTexts, _this.tag.childTexts);
            } else if (typeof _this.tag.decorationAfter === "string") {
              after = _this.tag.decorationAfter;
            }
            text = before + content + after;
            if (_this.tag.ignore) {
              text = "";
            } else if (_this.tag.inline) {
              text = text;
            } else if (_this.tag.singleLine) {
              text = "\n" + text.replace(/\n/g, "");
            } else {
              text = "\n" + text.replace(/\n\n+/g, "\n\n").trim() + "\n";
            }
            _this.tag.text = text;
            _this.stack.pop();
            _this.tag.childTexts.push(text);
            if (indexOf.call(_this.indentTagNames, tag) >= 0) {
              return _this.indent -= 1;
            }
          };
        })(this),
        chars: (function(_this) {
          return function(text) {
            return _this.tag.childTexts.push(htmlEntity.decode(text));
          };
        })(this)
      });
      return this.stack[0].childTexts.join("").trim();
      return "";
    };

    return HTMLStack;

  })();

  module.exports = (function(_this) {
    return function(html) {
      var items, markdown, stack;
      stack = [];
      items = [];
      HTMLParser(html, {
        start: function(tag, attrs, unary) {
          var current, el, last;
          el = new DomEl(tag, attrs);
          last = stack[stack.length - 1];
          if (!last) {
            stack.push(el);
            if (unary) {
              stack.pop();
            }
            return items.push(el);
          } else {
            stack.push(el);
            current = last;
            current.push(el);
            if (unary) {
              return stack.pop();
            }
          }
        },
        end: function(tag) {
          return stack.pop();
        },
        chars: function(text) {
          var el, last, results;
          el = new DomEl("TEXT_CONTENT", [
            {
              value: htmlEntity.decode(text),
              name: "text"
            }
          ]);
          last = stack[stack.length - 1];
          if (last) {
            last.push(el);
          } else {
            items.push(el);
          }
          el.contentLength = text.length;
          results = [];
          while (el.parent) {
            el = el.parent;
            results.push(el.contentLength += text.length);
          }
          return results;
        },
        comment: function() {}
      });
      markdown = toMarkdown(flatten(items));
      markdown = markdown.replace(/\n\n\n+/g, "\n\n").replace(/、\s*/g, "、 ");
      return markdown = markdown.replace(new RegExp("  +", "g"), " ");
    };
  })(this);

  flatten = function(items) {
    return items;
  };

  _stack = [];

  toMarkdown = function(doms, option) {
    var _, content, count, escapeMarkdownUrl, headline, hint, href, i, item, j, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, result, texts;
    if (option == null) {
      option = {};
    }
    texts = [];
    count = 0;
    escapeMarkdownUrl = function(string) {
      var _map, result;
      _map = {
        "(": "\\(",
        ")": "\\)",
        "\\": "\\\\"
      };
      result = string.replace(/\(|\)|\\/g, function(match) {
        return _map[match] || match;
      });
      return result;
    };
    for (i = 0, len = doms.length; i < len; i++) {
      item = doms[i];
      _stack.push(item.name);
      if (((ref = option.filter) != null ? ref.length : void 0) > 0 && (ref1 = item.name, indexOf.call(option.filter, ref1) < 0)) {
        if (option.plainWithoutFilter) {
          option.plain = true;
        } else {
          continue;
        }
      }
      if (option.limit) {
        count += 1;
        if (count > option.limit) {
          break;
        }
      }
      if ((ref2 = item.name) === "P" || ref2 === "div") {
        texts.push(toMarkdown(item.children, option).replace(/\n+/g, "\n") + "\n\n");
      } else if ((ref3 = item.name) === "H1" || ref3 === "H2" || ref3 === "H3" || ref3 === "H4" || ref3 === "H5" || ref3 === "H6") {
        if (option.plain) {
          headline = "";
        } else {
          count = parseInt(item.name[1]) || 1;
          headline = "";
          for (_ = j = 0, ref4 = count; 0 <= ref4 ? j < ref4 : j > ref4; _ = 0 <= ref4 ? ++j : --j) {
            headline += "#";
          }
          headline += " ";
        }
        texts.push("\n" + headline + " " + (toMarkdown(item.children, option).replace(/\n/g, " ")) + "\n");
      } else if (item.name === "PRE") {
        if (option.plain) {
          texts.push((toMarkdown(item.children, option).replace(/\n/g, " ")) + "\n\n");
        } else {
          texts.push("\b```\n");
          texts.push((toMarkdown(item.children, option).replace(/`/g, "\\`")) + "\n\n");
          texts.push("\n```\n");
        }
      } else if (item.name === "QUOTE") {
        if (option.plain) {
          headline = "";
        } else {
          headline = "> ";
        }
        texts.push("> " + (toMarkdown(item.children, option).replace(/\n/g, " ")) + "\n\n");
      } else if (item.name === "TEXT_CONTENT") {
        texts.push(((ref5 = item.attrs.text) != null ? typeof ref5.trim === "function" ? ref5.trim() : void 0 : void 0) || "");
      } else if (item.name === "A") {
        if (option.plain) {
          texts.push(toMarkdown(item.children, {
            plain: true
          }));
        } else {
          hint = toMarkdown(item.children, {
            plain: true,
            limit: 1,
            plainWithoutFilter: true,
            filter: ["IMG", "TEXT_CONTENT"]
          }).trim();
          href = item.attrs.href || "";
          if ((href != null ? href.indexOf("javascript:") : void 0) === 0) {
            href = "";
          }
          href = escapeMarkdownUrl(href || "");
          if (!href && !hint) {
            texts.push("");
          } else {
            texts.push(" [" + hint + "](" + href + ") ");
          }
        }
      } else if (item.name === "SPAN") {
        texts.push(toMarkdown(item.children, option));
      } else if (item.name === "IMG") {
        content = " ![" + (item.attrs.alt || item.attrs.title || "") + "](" + (escapeMarkdownUrl(item.attrs.src || "")) + ") ";
        if (option.plain) {
          texts.push(content);
        } else {
          texts.push("\n" + content + "\n");
        }
      } else if ((ref6 = item.name) === "B" || ref6 === "STRONG") {
        texts.push(" *" + (toMarkdown(item.children, {
          plain: true
        })) + "* ");
      } else if (item.name === "BR") {
        texts.push("\n");
      } else if ((ref7 = item.name) === "SCRIPT" || ref7 === "LINK" || ref7 === "STYLE") {
        texts.push("");
      } else {
        texts.push(toMarkdown(item.children, option));
      }
    }
    result = texts.join("").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    return result;
  };

  module.exports = (function(_this) {
    return function(html) {
      var stack;
      stack = new HTMLStack();
      return stack.parse(html);
    };
  })(this);

  module.exports.isHTMLSimple = function(html) {
    var complicatedTags, e, error, meaningfulTags;
    try {
      complicatedTags = ["IMG", "VIDEO", "TABLE", "NAV"];
      meaningfulTags = ["H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "LI"];
      HTMLParser(html, {
        start: function(tag) {
          var ref;
          if (ref = tag != null ? tag.toUpperCase() : void 0, indexOf.call(complicatedTags, ref) >= 0) {
            throw new Error("Not Simple!");
          }
        },
        chars: function() {},
        end: function() {}
      });
      return true;
    } catch (error) {
      e = error;
      Logger.error(e);
      return false;
    }
  };

}).call(this);
